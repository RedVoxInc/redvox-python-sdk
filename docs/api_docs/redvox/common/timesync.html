<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>redvox.common.timesync API documentation</title>
<meta name="description" content="Modules for extracting time synchronization statistics for API 900 and 1000 data.
Currently uses API M packets due to versatility of the packet.
Also …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.timesync</code></h1>
</header>
<section id="section-intro">
<p>Modules for extracting time synchronization statistics for API 900 and 1000 data.
Currently uses API M packets due to versatility of the packet.
Also includes functions for correcting time arrays.
ALL timestamps in microseconds unless otherwise stated</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Modules for extracting time synchronization statistics for API 900 and 1000 data.
Currently uses API M packets due to versatility of the packet.
Also includes functions for correcting time arrays.
ALL timestamps in microseconds unless otherwise stated
&#34;&#34;&#34;

from functools import reduce
from typing import List, Optional, Union

# noinspection Mypy
import numpy as np

import redvox.api900.lib.api900_pb2 as api900_pb2
from redvox.api1000.proto.redvox_api_m_pb2 import RedvoxPacketM
from redvox.api900.lib.api900_pb2 import RedvoxPacket
from redvox.common.offset_model import OffsetModel
import redvox.api900.reader_utils as util_900
from redvox.api1000.wrapped_redvox_packet.wrapped_packet import WrappedRedvoxPacketM
from redvox.api900.wrapped_redvox_packet import WrappedRedvoxPacket
from redvox.common.errors import RedVoxExceptions
from redvox.common import (
    stats_helper as sh,
    tri_message_stats as tms,
    date_time_utils as dt,
)


class TimeSyncData:
    &#34;&#34;&#34;
    Stores latencies, offsets, and other timesync related information about a single station
    ALL timestamps in microseconds unless otherwise stated
    properties:
        station_id: str, id of station, default empty string
        station_start_timestamp: float, timestamp of when the station was started, default np.nan
        sample_rate_hz: float, sample rate of audio sensor in Hz, default np.nan
        packet_start_timestamp: float, timestamp of when data started recording, default np.nan
        packet_end_timestamp: float, timestamp of when data stopped recording, default np.nan
        packet_duration: float, length of packet in microseconds, default 0.0
        server_acquisition_timestamp: float, timestamp of when packet arrived at server, default np.nan
        time_sync_exchanges_df: dataframe, timestamps that form the time synch exchanges, default empty dataframe
        latencies: np.ndarray, calculated latencies of the exchanges, default empty np.ndarray
        best_latency_index: int, index in latencies array that contains the best latency, default np.nan
        best_latency: float, best latency of the data, default np.nan
        mean_latency: float, mean latency, default np.nan
        latency_std: float, standard deviation of latencies, default np.nan
        offsets: np.ndarray, calculated offsets of the exchanges, default np.ndarray
        best_offset: float, best offset of the data, default np.nan
        mean_offset: float, mean offset, default np.nan
        offset_std: float, standard deviation of offsets, default np.nan
        best_tri_msg_index: int, index of the best tri-message (same as best_latency_index), default np.nan
        best_msg_timestamp_index: int = np.nan, 1 or 3, indicates which tri-message latency array has the best latency
        acquire_travel_time: float, calculated time it took packet to reach server, default np.nan
    &#34;&#34;&#34;

    def __init__(
            self,
            station_id: str = &#34;&#34;,
            sample_rate_hz: float = np.nan,
            num_audio_samples: int = np.nan,
            station_start_timestamp: float = np.nan,
            server_acquisition_timestamp: float = np.nan,
            packet_start_timestamp: float = np.nan,
            packet_end_timestamp: float = np.nan,
            time_sync_exchanges_list: Optional[List[float]] = None,
            best_latency: float = np.nan,
            best_offset: float = 0.0,
    ):
        &#34;&#34;&#34;
        Initialize properties
        :param station_id: id of station, default empty string
        :param sample_rate_hz: sample rate in hz of the station&#39;s audio channel, default np.nan
        :param num_audio_samples: number of audio samples in the data, default np.nan
        :param station_start_timestamp: timestamp of when the station started recording, default np.nan
        :param server_acquisition_timestamp: timestamp of when the data was received at the acquisition server,
                                                default np.nan
        :param packet_start_timestamp: timestamp of the start of the data packet, default np.nan
        :param packet_end_timestamp: timestamp of the end of the data packet, default np.nan
        :param time_sync_exchanges_list: the timesync exchanges of the packet as a flat list, default None
        :param best_latency: the best latency of the packet, default np.nan
        :param best_offset: the best offset of the packet, default 0.0
        &#34;&#34;&#34;
        self.station_id = station_id
        self.sample_rate_hz = sample_rate_hz
        self.num_audio_samples = num_audio_samples
        self.station_start_timestamp = station_start_timestamp
        self.server_acquisition_timestamp = server_acquisition_timestamp
        self.packet_start_timestamp = packet_start_timestamp
        self.packet_end_timestamp = packet_end_timestamp
        if time_sync_exchanges_list is None:
            time_sync_exchanges_list = []
        else:
            time_sync_exchanges_list = [
                time_sync_exchanges_list[i: i + 6]
                for i in range(0, len(time_sync_exchanges_list), 6)
            ]
        self.time_sync_exchanges_list = np.transpose(time_sync_exchanges_list)
        self.best_latency = best_latency
        self.best_offset = best_offset

        self._compute_tri_message_stats()
        # set the packet duration
        self.packet_duration = self.packet_end_timestamp - self.packet_start_timestamp
        # calculate travel time between corrected end of packet timestamp and server timestamp
        self.acquire_travel_time = self.server_acquisition_timestamp - (
                self.packet_end_timestamp + self.best_offset
        )

    def _compute_tri_message_stats(self):
        &#34;&#34;&#34;
        Compute the tri-message stats from the data
        &#34;&#34;&#34;
        if self.num_tri_messages() &gt; 0:
            # compute tri message data from time sync exchanges
            tse = tms.TriMessageStats(
                self.station_id,
                np.array(self.time_sync_exchanges_list[0]),
                np.array(self.time_sync_exchanges_list[1]),
                np.array(self.time_sync_exchanges_list[2]),
                np.array(self.time_sync_exchanges_list[3]),
                np.array(self.time_sync_exchanges_list[4]),
                np.array(self.time_sync_exchanges_list[5]),
            )
            # Compute the statistics for latency and offset
            self.mean_latency = np.mean([*tse.latency1, *tse.latency3])
            self.latency_std = np.std([*tse.latency1, *tse.latency3])
            self.mean_offset = np.mean([*tse.offset1, *tse.offset3])
            self.offset_std = np.std([*tse.offset1, *tse.offset3])
            self.latencies = np.array((tse.latency1, tse.latency3))
            self.offsets = np.array((tse.offset1, tse.offset3))
            self.best_latency_index = tse.best_latency_index
            self.best_tri_msg_index = tse.best_latency_index
            self.best_msg_timestamp_index = tse.best_latency_array_index
            # if best_latency is np.nan, set to best computed latency
            if np.isnan(self.best_latency):
                self.best_latency = tse.best_latency
                self.best_offset = tse.best_offset
            # if best_offset is still default value, use the best computed offset
            elif self.best_offset == 0:
                self.best_offset = tse.best_offset
        else:
            # If here, there are no exchanges to read.  write default or empty values to the correct properties
            self.best_tri_msg_index = np.nan
            self.best_latency_index = np.nan
            self.best_latency = np.nan
            self.mean_latency = np.nan
            self.latency_std = np.nan
            self.best_offset = 0
            self.mean_offset = 0
            self.offset_std = 0
            self.best_msg_timestamp_index = np.nan

    def num_tri_messages(self) -&gt; int:
        &#34;&#34;&#34;
        return the number of tri-message exchanges
        :return: number of tri-message exchanges
        &#34;&#34;&#34;
        return np.size(self.time_sync_exchanges_list, 0)

    def update_timestamps(self, om: Optional[OffsetModel]):
        &#34;&#34;&#34;
        update timestamps by adding microseconds based on the OffsetModel.
        if model not supplied, uses the best offset.
        uses negative values to go backwards in time
        :param om: OffsetModel to calculate offsets, default None
        &#34;&#34;&#34;
        if not om:
            delta = self.best_offset
            self.station_start_timestamp += delta
            self.packet_start_timestamp += delta
            self.packet_end_timestamp += delta
        else:
            self.station_start_timestamp = om.update_time(self.station_start_timestamp)
            self.packet_start_timestamp = om.update_time(self.packet_start_timestamp)
            self.packet_end_timestamp = om.update_time(self.packet_end_timestamp)

    def get_best_latency_timestamp(self) -&gt; float:
        &#34;&#34;&#34;
        :return: timestamp of best latency, or start of the packet if no best latency.
        &#34;&#34;&#34;
        if self.best_msg_timestamp_index == 1:
            return self.time_sync_exchanges_list[3][self.best_latency_index]
        elif self.best_msg_timestamp_index == 3:
            return self.time_sync_exchanges_list[5][self.best_latency_index]
        else:
            return self.packet_start_timestamp


def time_sync_data_from_raw_packet(packet: Union[RedvoxPacketM, RedvoxPacket]) -&gt; TimeSyncData:
    &#34;&#34;&#34;
    :param packet: data packet to get time sync data from
    :return: TimeSyncData object from data packet
    &#34;&#34;&#34;
    tsd: TimeSyncData
    if isinstance(packet, RedvoxPacketM):
        exchanges: List[float] = reduce(lambda acc, ex: acc + [ex.a1, ex.a2, ex.a3, ex.b1, ex.b2, ex.b3],
                                        packet.timing_information.synch_exchanges,
                                        [])
        tsd = TimeSyncData(
            packet.station_information.id,
            packet.sensors.audio.sample_rate,
            len(packet.sensors.audio.samples.values),
            packet.timing_information.app_start_mach_timestamp,
            packet.timing_information.server_acquisition_arrival_timestamp,
            packet.timing_information.packet_start_mach_timestamp,
            packet.timing_information.packet_end_mach_timestamp,
            exchanges,
            packet.timing_information.best_latency,
            packet.timing_information.best_offset
        )
    else:
        mtz: float = np.nan
        best_latency: float = np.nan
        best_offset: float = np.nan

        for i, v in enumerate(packet.metadata):
            plus_1: int = i + 1
            try:
                if v == &#34;machTimeZero&#34; and plus_1 &lt; len(packet.metadata):
                    mtz = float(packet.metadata[plus_1])
                if v == &#34;bestLatency&#34; and plus_1 &lt; len(packet.metadata):
                    best_latency = float(packet.metadata[plus_1])
                if v == &#34;bestOffset&#34; and plus_1 &lt; len(packet.metadata):
                    best_offset = float(packet.metadata[plus_1])
            except (KeyError, ValueError):
                continue

        # Get synch exchanges
        exchanges: Optional[np.ndarray] = None
        ch: api900_pb2.UnevenlySampledChannel
        for ch in packet.unevenly_sampled_channels:
            if api900_pb2.TIME_SYNCHRONIZATION in ch.channel_types:
                exchanges = util_900.extract_payload(ch)

        tsd = TimeSyncData(
            packet.redvox_id,
            packet.evenly_sampled_channels[0].sample_rate_hz,
            util_900.payload_len(packet.evenly_sampled_channels[0]),
            mtz,
            packet.evenly_sampled_channels[0].first_sample_timestamp_epoch_microseconds_utc,
            packet.server_timestamp_epoch_microseconds_utc,
            packet.app_file_start_timestamp_machine,
            list(exchanges),
            best_latency,
            best_offset,
        )

    return tsd


class TimeSyncAnalysis:
    &#34;&#34;&#34;
    Used for multiple TimeSyncData objects from a station
    properties:
        station_id: string, the station_id of the station being analyzed, default empty string
        best_latency_index: int, the index of the TimeSyncData object with the best latency, default np.nan
        latency_stats: StatsContainer, the statistics of the latencies
        offset_stats: StatsContainer, the statistics of the offsets
        offset_model: optional OffsetModel, used to calculate offset at a given point in time
        sample_rate_hz: float, the audio sample rate in hz of the station, default np.nan
        timesync_data: list of TimeSyncData, the TimeSyncData to analyze, default empty list
        station_start_timestamp: float, the timestamp of when the station became active, default np.nan
    &#34;&#34;&#34;

    def __init__(
            self,
            station_id: str = &#34;&#34;,
            audio_sample_rate_hz: float = np.nan,
            station_start_timestamp: float = np.nan,
            time_sync_data: Optional[List[TimeSyncData]] = None,
    ):
        &#34;&#34;&#34;
        Initialize the object
        :param station_id: id of the station to analyze, default empty string
        :param audio_sample_rate_hz: audio sample rate in hz of the station, default np.nan
        :param station_start_timestamp: timestamp of when station started recording, default np.nan
        :param time_sync_data: the TimeSyncData objects created from the packets of the station, default None
        &#34;&#34;&#34;
        self.station_id: str = station_id
        self.sample_rate_hz: float = audio_sample_rate_hz
        self.station_start_timestamp: float = station_start_timestamp
        self.best_latency_index: int = np.nan
        self.latency_stats = sh.StatsContainer(&#34;latency&#34;)
        self.offset_stats = sh.StatsContainer(&#34;offset&#34;)
        self.errors = RedVoxExceptions(&#34;TimeSyncAnalysis&#34;)
        if time_sync_data:
            self.timesync_data: List[TimeSyncData] = time_sync_data
            self.evaluate_and_validate_data()
        else:
            self.timesync_data = []
            self.offset_model = OffsetModel.empty_model()

    def evaluate_and_validate_data(self):
        &#34;&#34;&#34;
        check the data for errors and update the analysis statistics
        &#34;&#34;&#34;
        self.evaluate_latencies()
        self.validate_start_timestamp()
        self.validate_sample_rate()
        self._calc_timesync_stats()
        self.offset_model = self.get_offset_model()

    def get_offset_model(self) -&gt; OffsetModel:
        &#34;&#34;&#34;
        :return: an OffsetModel based on the information in the timesync analysis
        &#34;&#34;&#34;
        return OffsetModel(self.get_latencies(), self.get_offsets(),
                           np.array([td.get_best_latency_timestamp() for td in self.timesync_data]),
                           self.timesync_data[0].packet_start_timestamp,
                           self.timesync_data[-1].packet_end_timestamp)

    def _calc_timesync_stats(self):
        &#34;&#34;&#34;
        calculates the mean and std deviation for latencies and offsets
        &#34;&#34;&#34;
        if len(self.timesync_data) &lt; 1:
            self.errors.append(
                &#34;Nothing to calculate stats; length of timesync data is less than 1&#34;
            )
        else:
            for index in range(len(self.timesync_data)):
                # add the stats of the latency
                self.latency_stats.add(
                    self.timesync_data[index].mean_latency,
                    self.timesync_data[index].latency_std,
                    self.timesync_data[index].num_tri_messages() * 2,
                    )
                # add the stats of the offset
                self.offset_stats.add(
                    self.timesync_data[index].mean_offset,
                    self.timesync_data[index].offset_std,
                    self.timesync_data[index].num_tri_messages() * 2,
                    )
            self.latency_stats.best_value = self.get_best_latency()
            self.offset_stats.best_value = self.get_best_offset()

    def from_packets(self, packets: List[Union[WrappedRedvoxPacketM, WrappedRedvoxPacket]]) -&gt; &#39;TimeSyncAnalysis&#39;:
        &#34;&#34;&#34;
        converts packets into TimeSyncData objects, then performs analysis
        :param packets: list of WrappedRedvoxPacketM to convert
        :return: modified version of self
        &#34;&#34;&#34;
        self.timesync_data = [TimeSyncData(self.station_id,
                                           self.sample_rate_hz,
                                           packet.get_sensors().get_audio().get_num_samples(),
                                           self.station_start_timestamp,
                                           packet.get_timing_information().get_server_acquisition_arrival_timestamp(),
                                           packet.get_timing_information().get_packet_start_mach_timestamp(),
                                           packet.get_timing_information().get_packet_end_mach_timestamp(),
                                           packet.get_timing_information().get_synch_exchange_array(),
                                           packet.get_timing_information().get_best_latency(),
                                           packet.get_timing_information().get_best_offset(),
                                           )
                              if isinstance(packet, WrappedRedvoxPacketM) else
                              TimeSyncData(self.station_id,
                                           self.sample_rate_hz,
                                           packet.microphone_sensor().payload_values().size,
                                           self.station_start_timestamp,
                                           packet.server_timestamp_epoch_microseconds_utc(),
                                           packet.start_timestamp_us_utc(),
                                           packet.end_timestamp_us_utc(),
                                           list(packet.time_synchronization_sensor().payload_values()),
                                           packet.best_latency(),
                                           packet.best_offset(),
                                           )
                              for packet in packets]
        if len(self.timesync_data) &gt; 0:
            self.evaluate_and_validate_data()
        return self

    def from_raw_packets(self, packets: List[Union[RedvoxPacketM, RedvoxPacket]]) -&gt; &#39;TimeSyncAnalysis&#39;:
        &#34;&#34;&#34;
        converts packets into TimeSyncData objects, then performs analysis
        :param packets: list of WrappedRedvoxPacketM to convert
        :return: modified version of self
        &#34;&#34;&#34;
        timesync_data: List[TimeSyncData] = []

        packet: Union[RedvoxPacketM, RedvoxPacket]
        for packet in packets:
            tsd: TimeSyncData
            if isinstance(packet, RedvoxPacketM):
                exchanges: List[float] = reduce(lambda acc, ex: acc + [ex.a1, ex.a2, ex.a3, ex.b1, ex.b2, ex.b3],
                                                packet.timing_information.synch_exchanges,
                                                [])
                tsd = TimeSyncData(
                    packet.station_information.id,
                    packet.sensors.audio.sample_rate,
                    len(packet.sensors.audio.samples.values),
                    packet.timing_information.app_start_mach_timestamp,
                    packet.timing_information.server_acquisition_arrival_timestamp,
                    packet.timing_information.packet_start_mach_timestamp,
                    packet.timing_information.packet_end_mach_timestamp,
                    exchanges,
                    packet.timing_information.best_latency,
                    packet.timing_information.best_offset
                )
            else:
                mtz: float = np.nan
                best_latency: float = np.nan
                best_offset: float = np.nan

                for i, v in enumerate(packet.metadata):
                    plus_1: int = i + 1
                    try:
                        if v == &#34;machTimeZero&#34; and plus_1 &lt; len(packet.metadata):
                            mtz = float(packet.metadata[plus_1])
                        if v == &#34;bestLatency&#34; and plus_1 &lt; len(packet.metadata):
                            best_latency = float(packet.metadata[plus_1])
                        if v == &#34;bestOffset&#34; and plus_1 &lt; len(packet.metadata):
                            best_offset = float(packet.metadata[plus_1])
                    except (KeyError, ValueError):
                        continue

                # Get synch exchanges
                exchanges: Optional[np.ndarray] = None
                ch: api900_pb2.UnevenlySampledChannel
                for ch in packet.unevenly_sampled_channels:
                    if api900_pb2.TIME_SYNCHRONIZATION in ch.channel_types:
                        exchanges = util_900.extract_payload(ch)

                tsd = TimeSyncData(
                    packet.redvox_id,
                    packet.evenly_sampled_channels[0].sample_rate_hz,
                    util_900.payload_len(packet.evenly_sampled_channels[0]),
                    mtz,
                    packet.evenly_sampled_channels[0].first_sample_timestamp_epoch_microseconds_utc,
                    packet.server_timestamp_epoch_microseconds_utc,
                    packet.app_file_start_timestamp_machine,
                    list(exchanges),
                    best_latency,
                    best_offset,
                )

            timesync_data.append(tsd)

        self.timesync_data = timesync_data

        if len(self.timesync_data) &gt; 0:
            self.evaluate_and_validate_data()

        return self

    def add_timesync_data(self, timesync_data: TimeSyncData):
        &#34;&#34;&#34;
        adds a TimeSyncData object to the analysis
        :param timesync_data: TimeSyncData to add
        &#34;&#34;&#34;
        self.timesync_data.append(timesync_data)
        self.evaluate_and_validate_data()

    def get_num_packets(self) -&gt; int:
        &#34;&#34;&#34;
        :return: number of packets analyzed
        &#34;&#34;&#34;
        return len(self.timesync_data)

    def get_best_latency(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].best_latency

    def get_latencies(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: np.array containing all the latencies
        &#34;&#34;&#34;
        return np.array([ts_data.best_latency for ts_data in self.timesync_data])

    def get_mean_latency(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the mean of the latencies, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.latency_stats.mean_of_means()

    def get_latency_stdev(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the standard deviation of the latencies, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.latency_stats.total_std_dev()

    def get_best_offset(self) -&gt; float:
        &#34;&#34;&#34;
        :return: offset associated with the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].best_offset

    def get_offsets(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: np.array containing all the offsets
        &#34;&#34;&#34;
        return np.array([ts_data.best_offset for ts_data in self.timesync_data])

    def get_mean_offset(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the mean of the offsets, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.offset_stats.mean_of_means()

    def get_offset_stdev(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the standard deviation of the offsets, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.offset_stats.total_std_dev()

    def get_best_packet_latency_index(self) -&gt; int:
        &#34;&#34;&#34;
        :return: the best latency&#39;s index in the packet with the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].best_latency_index

    def get_best_start_time(self) -&gt; float:
        &#34;&#34;&#34;
        :return: start timestamp associated with the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].packet_start_timestamp

    def get_start_times(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: list of the start timestamps of each packet
        &#34;&#34;&#34;
        start_times = []
        for ts_data in self.timesync_data:
            start_times.append(ts_data.packet_start_timestamp)
        return np.array(start_times)

    def get_bad_packets(self) -&gt; List[int]:
        &#34;&#34;&#34;
        :return: list of all packets that contains invalid data
        &#34;&#34;&#34;
        bad_packets = []
        for idx in range(
                self.get_num_packets()
        ):  # mark bad indices (they have a 0 or less value)
            if self.get_latencies()[idx] &lt;= 0 or np.isnan(self.get_latencies()[idx]):
                bad_packets.append(idx)
        return bad_packets

    def evaluate_latencies(self):
        &#34;&#34;&#34;
        finds the best latency
        outputs warnings if a change in timestamps is detected
        &#34;&#34;&#34;
        if self.get_num_packets() &lt; 1:
            self.errors.append(
                &#34;Latencies cannot be evaluated; length of timesync data is less than 1&#34;
            )
        else:
            self.best_latency_index = 0
            # assume the first element has the best timesync values for now, then compare with the others
            for index in range(1, self.get_num_packets()):
                best_latency = self.get_best_latency()
                # find the best latency; in this case, the minimum
                # if new value exists and if the current best does not or new value is better than current best, update
                if (not np.isnan(self.timesync_data[index].best_latency) and (np.isnan(best_latency))
                        or self.timesync_data[index].best_latency &lt; best_latency):
                    self.best_latency_index = index

    def validate_start_timestamp(self, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        confirms if station_start_timestamp differs in any of the timesync_data
        outputs warnings if a change in timestamps is detected
        :param debug: if True, output warning message, default False
        :return: True if no change
        &#34;&#34;&#34;
        for index in range(self.get_num_packets()):
            # compare station start timestamps; notify when they are different
            if (
                    self.timesync_data[index].station_start_timestamp
                    != self.station_start_timestamp
            ):
                self.errors.append(
                    f&#34;Change in station start timestamp detected; &#34;
                    f&#34;expected: {self.station_start_timestamp}, read: &#34;
                    f&#34;{self.timesync_data[index].station_start_timestamp}&#34;
                )
                if debug:
                    self.errors.print()
                return False
        # if here, all the sample timestamps are the same
        return True

    def validate_sample_rate(self, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        confirms if sample rate is the same across all timesync_data
        outputs warning if a change in sample rate is detected
        :param debug: if True, output warning message, default False
        :return: True if no change
        &#34;&#34;&#34;
        for index in range(self.get_num_packets()):
            # compare station start timestamps; notify when they are different
            if (
                    np.isnan(self.timesync_data[index].sample_rate_hz)
                    or self.timesync_data[index].sample_rate_hz != self.sample_rate_hz
            ):
                self.errors.append(
                    f&#34;Change in station sample rate detected; &#34;
                    f&#34;expected: {self.sample_rate_hz}, read: {self.timesync_data[index].sample_rate_hz}&#34;
                )
                if debug:
                    self.errors.print()
                return False
        # if here, all the sample rates are the same
        return True

    def validate_time_gaps(self, gap_duration_s: float, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        confirms there are no data gaps between packets
        outputs warning if a gap is detected
        :param gap_duration_s: length of time in seconds to be detected as a gap
        :param debug: if True, output warning message, default False
        :return: True if no gap
        &#34;&#34;&#34;
        if self.get_num_packets() &lt; 2:
            self.errors.append(&#34;Less than 2 timesync data objects to evaluate gaps with&#34;)
            if debug:
                self.errors.print()
        else:
            for index in range(1, self.get_num_packets()):
                # compare last packet&#39;s end timestamp with current start timestamp
                if (
                        dt.microseconds_to_seconds(
                            self.timesync_data[index].packet_start_timestamp
                            - self.timesync_data[index - 1].packet_end_timestamp
                        )
                        &gt; gap_duration_s
                ):
                    self.errors.append(f&#34;Gap detected at packet number: {index}&#34;)
                    if debug:
                        self.errors.print()
                    return False
        # if here, no gaps
        return True

    def update_timestamps(self, use_model: bool = True):
        &#34;&#34;&#34;
        update timestamps by adding microseconds based on the OffsetModel.
        :param use_model: if True, use the model, otherwise use best offset
        &#34;&#34;&#34;
        if use_model and self.offset_model:
            self.station_start_timestamp += self.offset_model.get_offset_at_new_time(self.station_start_timestamp)
            for tsd in self.timesync_data:
                tsd.update_timestamps(self.offset_model)
        else:
            self.station_start_timestamp += self.get_best_offset()
            for tsd in self.timesync_data:
                tsd.update_timestamps()


def validate_sensors(tsa_data: TimeSyncAnalysis) -&gt; bool:
    &#34;&#34;&#34;
    Examine all sample rates and mach time zeros to ensure that sensor settings do not change
    :param tsa_data: the TimeSyncAnalysis data to validate
    :return: True if sensor settings do not change
    &#34;&#34;&#34;
    # check that we have packets to read
    if tsa_data.get_num_packets() &lt; 1:
        print(&#34;ERROR: no data to validate.&#34;)
        return False
    elif tsa_data.get_num_packets() &gt; 1:
        # if we have more than one packet, we need to validate the data
        return tsa_data.validate_sample_rate() and tsa_data.validate_start_timestamp()
    # we get here if all packets have the same sample rate and mach time zero
    return True


def update_evenly_sampled_time_array(
        ts_analysis: TimeSyncAnalysis,
        num_samples: float = None,
        time_start_array_s: np.array = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Correct evenly sampled times using updated time_start_array values as the focal point.
    Expects tsd to have the same number of packets as elements in time_start_array.
    Expects there are no gaps in the data or changes in station sample rate or start time.
    Throws an exception if the number of packets in tsa does not match the length of time_start_array
    :param ts_analysis: TimeSyncAnalysis object that contains the information needed to update the time array
    :param num_samples: number of samples in one file; optional, uses number based on sample rate if not given
    :param time_start_array_s: the array of timestamps to correct in seconds; optional, uses the start times in the
                             TimeSyncAnalysis object if not given
    :return: Revised time array in epoch seconds
    &#34;&#34;&#34;
    if not validate_sensors(ts_analysis):
        raise AttributeError(
            &#34;ERROR: Change in Station Start Time or Sample Rate detected!&#34;
        )
    if time_start_array_s is None:
        # replace the time_start_array with values from tsd; convert tsd times to seconds
        time_start_array_s = np.array([])
        for tsd in ts_analysis.timesync_data:
            time_start_array_s = np.append(
                time_start_array_s,
                tsd.packet_start_timestamp / dt.MICROSECONDS_IN_SECOND,
                )
    num_files = len(ts_analysis.timesync_data)
    # the TimeSyncData must have the same number of packets as the number of elements in time_start_array
    if num_files != len(time_start_array_s):
        # alert the user, then quit
        raise Exception(
            &#34;ERROR: Attempted to update a time array that doesn&#39;t contain &#34;
            &#34;the same number of elements as the TimeSyncAnalysis!&#34;
        )

    # use the number of audio samples in the first data packet
    if num_samples is None:
        num_samples = ts_analysis.timesync_data[0].num_audio_samples
    t_dt = 1.0 / ts_analysis.sample_rate_hz

    # Use TimeSyncData object to find best start index.
    # Samples before will be the number of decoders before a0 times the number of samples in a file.
    # Samples after will be the number of decoders after a0 times the number of samples in a file minus 1;
    # the minus one represents the best a0.
    decoder_idx = ts_analysis.best_latency_index
    samples_before = int(decoder_idx * num_samples)
    samples_after = round((num_files - decoder_idx) * num_samples) - 1
    best_start_sec = time_start_array_s[decoder_idx]

    # build the time arrays separately in epoch seconds, then join into one
    # add 1 to include the actual a0 sample, then add 1 again to skip the a0 sample; this avoids repetition
    timesec_before = np.vectorize(lambda t: best_start_sec - t * t_dt)(
        list(range(int(samples_before + 1)))
    )
    timesec_before = timesec_before[
                     ::-1
                     ]  # reverse &#39;before&#39; times so they increase from earliest start time
    timesec_after = np.vectorize(lambda t: best_start_sec + t * t_dt)(
        list(range(1, int(samples_after + 1)))
    )
    timesec_rev = np.concatenate([timesec_before, timesec_after])

    return update_time_array_from_analysis(ts_analysis, timesec_rev)


def update_time_array(ts_data: TimeSyncData, time_array_s: np.array) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Correct timestamps in time_array using information from TimeSyncData
    :param ts_data: TimeSyncData object that contains the information needed to update the time array
    :param time_array_s: the list of timestamps to correct in seconds
    :return: Revised time array in epoch seconds
    &#34;&#34;&#34;
    return time_array_s + (ts_data.best_offset / dt.MICROSECONDS_IN_SECOND)


def update_time_array_from_analysis(
        ts_analysis: TimeSyncAnalysis, time_array_s: np.array
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Correct timestamps in time_array using information from TimeSyncAnalysis
    :param ts_analysis: TimeSyncAnalysis object that contains the information needed to update the time array
    :param time_array_s: the list of timestamps to correct in seconds
    :return: Revised time array in epoch seconds
    &#34;&#34;&#34;
    return time_array_s + (ts_analysis.get_best_offset() / dt.MICROSECONDS_IN_SECOND)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.common.timesync.time_sync_data_from_raw_packet"><code class="name flex">
<span>def <span class="ident">time_sync_data_from_raw_packet</span></span>(<span>packet: Union[src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM, api900_pb2.RedvoxPacket]) ‑> <a title="redvox.common.timesync.TimeSyncData" href="#redvox.common.timesync.TimeSyncData">TimeSyncData</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param packet: data packet to get time sync data from
:return: TimeSyncData object from data packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_sync_data_from_raw_packet(packet: Union[RedvoxPacketM, RedvoxPacket]) -&gt; TimeSyncData:
    &#34;&#34;&#34;
    :param packet: data packet to get time sync data from
    :return: TimeSyncData object from data packet
    &#34;&#34;&#34;
    tsd: TimeSyncData
    if isinstance(packet, RedvoxPacketM):
        exchanges: List[float] = reduce(lambda acc, ex: acc + [ex.a1, ex.a2, ex.a3, ex.b1, ex.b2, ex.b3],
                                        packet.timing_information.synch_exchanges,
                                        [])
        tsd = TimeSyncData(
            packet.station_information.id,
            packet.sensors.audio.sample_rate,
            len(packet.sensors.audio.samples.values),
            packet.timing_information.app_start_mach_timestamp,
            packet.timing_information.server_acquisition_arrival_timestamp,
            packet.timing_information.packet_start_mach_timestamp,
            packet.timing_information.packet_end_mach_timestamp,
            exchanges,
            packet.timing_information.best_latency,
            packet.timing_information.best_offset
        )
    else:
        mtz: float = np.nan
        best_latency: float = np.nan
        best_offset: float = np.nan

        for i, v in enumerate(packet.metadata):
            plus_1: int = i + 1
            try:
                if v == &#34;machTimeZero&#34; and plus_1 &lt; len(packet.metadata):
                    mtz = float(packet.metadata[plus_1])
                if v == &#34;bestLatency&#34; and plus_1 &lt; len(packet.metadata):
                    best_latency = float(packet.metadata[plus_1])
                if v == &#34;bestOffset&#34; and plus_1 &lt; len(packet.metadata):
                    best_offset = float(packet.metadata[plus_1])
            except (KeyError, ValueError):
                continue

        # Get synch exchanges
        exchanges: Optional[np.ndarray] = None
        ch: api900_pb2.UnevenlySampledChannel
        for ch in packet.unevenly_sampled_channels:
            if api900_pb2.TIME_SYNCHRONIZATION in ch.channel_types:
                exchanges = util_900.extract_payload(ch)

        tsd = TimeSyncData(
            packet.redvox_id,
            packet.evenly_sampled_channels[0].sample_rate_hz,
            util_900.payload_len(packet.evenly_sampled_channels[0]),
            mtz,
            packet.evenly_sampled_channels[0].first_sample_timestamp_epoch_microseconds_utc,
            packet.server_timestamp_epoch_microseconds_utc,
            packet.app_file_start_timestamp_machine,
            list(exchanges),
            best_latency,
            best_offset,
        )

    return tsd</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.update_evenly_sampled_time_array"><code class="name flex">
<span>def <span class="ident">update_evenly_sampled_time_array</span></span>(<span>ts_analysis: <a title="redvox.common.timesync.TimeSyncAnalysis" href="#redvox.common.timesync.TimeSyncAnalysis">TimeSyncAnalysis</a>, num_samples: float = None, time_start_array_s: <built-in function array> = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Correct evenly sampled times using updated time_start_array values as the focal point.
Expects tsd to have the same number of packets as elements in time_start_array.
Expects there are no gaps in the data or changes in station sample rate or start time.
Throws an exception if the number of packets in tsa does not match the length of time_start_array
:param ts_analysis: TimeSyncAnalysis object that contains the information needed to update the time array
:param num_samples: number of samples in one file; optional, uses number based on sample rate if not given
:param time_start_array_s: the array of timestamps to correct in seconds; optional, uses the start times in the
TimeSyncAnalysis object if not given
:return: Revised time array in epoch seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_evenly_sampled_time_array(
        ts_analysis: TimeSyncAnalysis,
        num_samples: float = None,
        time_start_array_s: np.array = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Correct evenly sampled times using updated time_start_array values as the focal point.
    Expects tsd to have the same number of packets as elements in time_start_array.
    Expects there are no gaps in the data or changes in station sample rate or start time.
    Throws an exception if the number of packets in tsa does not match the length of time_start_array
    :param ts_analysis: TimeSyncAnalysis object that contains the information needed to update the time array
    :param num_samples: number of samples in one file; optional, uses number based on sample rate if not given
    :param time_start_array_s: the array of timestamps to correct in seconds; optional, uses the start times in the
                             TimeSyncAnalysis object if not given
    :return: Revised time array in epoch seconds
    &#34;&#34;&#34;
    if not validate_sensors(ts_analysis):
        raise AttributeError(
            &#34;ERROR: Change in Station Start Time or Sample Rate detected!&#34;
        )
    if time_start_array_s is None:
        # replace the time_start_array with values from tsd; convert tsd times to seconds
        time_start_array_s = np.array([])
        for tsd in ts_analysis.timesync_data:
            time_start_array_s = np.append(
                time_start_array_s,
                tsd.packet_start_timestamp / dt.MICROSECONDS_IN_SECOND,
                )
    num_files = len(ts_analysis.timesync_data)
    # the TimeSyncData must have the same number of packets as the number of elements in time_start_array
    if num_files != len(time_start_array_s):
        # alert the user, then quit
        raise Exception(
            &#34;ERROR: Attempted to update a time array that doesn&#39;t contain &#34;
            &#34;the same number of elements as the TimeSyncAnalysis!&#34;
        )

    # use the number of audio samples in the first data packet
    if num_samples is None:
        num_samples = ts_analysis.timesync_data[0].num_audio_samples
    t_dt = 1.0 / ts_analysis.sample_rate_hz

    # Use TimeSyncData object to find best start index.
    # Samples before will be the number of decoders before a0 times the number of samples in a file.
    # Samples after will be the number of decoders after a0 times the number of samples in a file minus 1;
    # the minus one represents the best a0.
    decoder_idx = ts_analysis.best_latency_index
    samples_before = int(decoder_idx * num_samples)
    samples_after = round((num_files - decoder_idx) * num_samples) - 1
    best_start_sec = time_start_array_s[decoder_idx]

    # build the time arrays separately in epoch seconds, then join into one
    # add 1 to include the actual a0 sample, then add 1 again to skip the a0 sample; this avoids repetition
    timesec_before = np.vectorize(lambda t: best_start_sec - t * t_dt)(
        list(range(int(samples_before + 1)))
    )
    timesec_before = timesec_before[
                     ::-1
                     ]  # reverse &#39;before&#39; times so they increase from earliest start time
    timesec_after = np.vectorize(lambda t: best_start_sec + t * t_dt)(
        list(range(1, int(samples_after + 1)))
    )
    timesec_rev = np.concatenate([timesec_before, timesec_after])

    return update_time_array_from_analysis(ts_analysis, timesec_rev)</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.update_time_array"><code class="name flex">
<span>def <span class="ident">update_time_array</span></span>(<span>ts_data: <a title="redvox.common.timesync.TimeSyncData" href="#redvox.common.timesync.TimeSyncData">TimeSyncData</a>, time_array_s: <built-in function array>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Correct timestamps in time_array using information from TimeSyncData
:param ts_data: TimeSyncData object that contains the information needed to update the time array
:param time_array_s: the list of timestamps to correct in seconds
:return: Revised time array in epoch seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_time_array(ts_data: TimeSyncData, time_array_s: np.array) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Correct timestamps in time_array using information from TimeSyncData
    :param ts_data: TimeSyncData object that contains the information needed to update the time array
    :param time_array_s: the list of timestamps to correct in seconds
    :return: Revised time array in epoch seconds
    &#34;&#34;&#34;
    return time_array_s + (ts_data.best_offset / dt.MICROSECONDS_IN_SECOND)</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.update_time_array_from_analysis"><code class="name flex">
<span>def <span class="ident">update_time_array_from_analysis</span></span>(<span>ts_analysis: <a title="redvox.common.timesync.TimeSyncAnalysis" href="#redvox.common.timesync.TimeSyncAnalysis">TimeSyncAnalysis</a>, time_array_s: <built-in function array>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Correct timestamps in time_array using information from TimeSyncAnalysis
:param ts_analysis: TimeSyncAnalysis object that contains the information needed to update the time array
:param time_array_s: the list of timestamps to correct in seconds
:return: Revised time array in epoch seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_time_array_from_analysis(
        ts_analysis: TimeSyncAnalysis, time_array_s: np.array
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Correct timestamps in time_array using information from TimeSyncAnalysis
    :param ts_analysis: TimeSyncAnalysis object that contains the information needed to update the time array
    :param time_array_s: the list of timestamps to correct in seconds
    :return: Revised time array in epoch seconds
    &#34;&#34;&#34;
    return time_array_s + (ts_analysis.get_best_offset() / dt.MICROSECONDS_IN_SECOND)</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.validate_sensors"><code class="name flex">
<span>def <span class="ident">validate_sensors</span></span>(<span>tsa_data: <a title="redvox.common.timesync.TimeSyncAnalysis" href="#redvox.common.timesync.TimeSyncAnalysis">TimeSyncAnalysis</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Examine all sample rates and mach time zeros to ensure that sensor settings do not change
:param tsa_data: the TimeSyncAnalysis data to validate
:return: True if sensor settings do not change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_sensors(tsa_data: TimeSyncAnalysis) -&gt; bool:
    &#34;&#34;&#34;
    Examine all sample rates and mach time zeros to ensure that sensor settings do not change
    :param tsa_data: the TimeSyncAnalysis data to validate
    :return: True if sensor settings do not change
    &#34;&#34;&#34;
    # check that we have packets to read
    if tsa_data.get_num_packets() &lt; 1:
        print(&#34;ERROR: no data to validate.&#34;)
        return False
    elif tsa_data.get_num_packets() &gt; 1:
        # if we have more than one packet, we need to validate the data
        return tsa_data.validate_sample_rate() and tsa_data.validate_start_timestamp()
    # we get here if all packets have the same sample rate and mach time zero
    return True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.timesync.RedvoxPacket"><code class="flex name class">
<span>class <span class="ident">RedvoxPacket</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.pyext._message.CMessage</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.timesync.RedvoxPacket.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="redvox.common.timesync.RedvoxPacket.acquisition_server"><code class="name">var <span class="ident">acquisition_server</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.acquisition_server</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.api"><code class="name">var <span class="ident">api</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.api</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc"><code class="name">var <span class="ident">app_file_start_timestamp_epoch_microseconds_utc</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.app_file_start_timestamp_machine"><code class="name">var <span class="ident">app_file_start_timestamp_machine</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.app_file_start_timestamp_machine</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.app_version"><code class="name">var <span class="ident">app_version</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.app_version</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.authenticated_email"><code class="name">var <span class="ident">authenticated_email</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.authenticated_email</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.authentication_server"><code class="name">var <span class="ident">authentication_server</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.authentication_server</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.authentication_token"><code class="name">var <span class="ident">authentication_token</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.authentication_token</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.battery_level_percent"><code class="name">var <span class="ident">battery_level_percent</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.battery_level_percent</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.device_make"><code class="name">var <span class="ident">device_make</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.device_make</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.device_model"><code class="name">var <span class="ident">device_model</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.device_model</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.device_os"><code class="name">var <span class="ident">device_os</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.device_os</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.device_os_version"><code class="name">var <span class="ident">device_os_version</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.device_os_version</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.device_temperature_c"><code class="name">var <span class="ident">device_temperature_c</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.device_temperature_c</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.evenly_sampled_channels"><code class="name">var <span class="ident">evenly_sampled_channels</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.evenly_sampled_channels</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.firebase_token"><code class="name">var <span class="ident">firebase_token</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.firebase_token</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.is_backfilled"><code class="name">var <span class="ident">is_backfilled</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.is_backfilled</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.is_private"><code class="name">var <span class="ident">is_private</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.is_private</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.is_scrambled"><code class="name">var <span class="ident">is_scrambled</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.is_scrambled</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.metadata</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.redvox_id"><code class="name">var <span class="ident">redvox_id</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.redvox_id</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.server_timestamp_epoch_microseconds_utc"><code class="name">var <span class="ident">server_timestamp_epoch_microseconds_utc</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.server_timestamp_epoch_microseconds_utc</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.time_synchronization_server"><code class="name">var <span class="ident">time_synchronization_server</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.time_synchronization_server</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.unevenly_sampled_channels"><code class="name">var <span class="ident">unevenly_sampled_channels</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.unevenly_sampled_channels</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacket.uuid"><code class="name">var <span class="ident">uuid</span></code></dt>
<dd>
<div class="desc"><p>Field RedvoxPacket.uuid</p></div>
</dd>
</dl>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM"><code class="flex name class">
<span>class <span class="ident">RedvoxPacketM</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.pyext._message.CMessage</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.timesync.RedvoxPacketM.BYTE"><code class="name">var <span class="ident">BYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.CENTIMETERS"><code class="name">var <span class="ident">CENTIMETERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.DECIBEL"><code class="name">var <span class="ident">DECIBEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.DECIMAL_DEGREES"><code class="name">var <span class="ident">DECIMAL_DEGREES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.DEGREES_CELSIUS"><code class="name">var <span class="ident">DEGREES_CELSIUS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.DoubleSamplePayload"><code class="name">var <span class="ident">DoubleSamplePayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.EventStream"><code class="name">var <span class="ident">EventStream</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.KILOPASCAL"><code class="name">var <span class="ident">KILOPASCAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS"><code class="name">var <span class="ident">LSB_PLUS_MINUS_COUNTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.LUX"><code class="name">var <span class="ident">LUX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.METERS"><code class="name">var <span class="ident">METERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.METERS_PER_SECOND"><code class="name">var <span class="ident">METERS_PER_SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.METERS_PER_SECOND_SQUARED"><code class="name">var <span class="ident">METERS_PER_SECOND_SQUARED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.MICROAMPERES"><code class="name">var <span class="ident">MICROAMPERES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH"><code class="name">var <span class="ident">MICROSECONDS_SINCE_UNIX_EPOCH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.MICROTESLA"><code class="name">var <span class="ident">MICROTESLA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.MetadataEntry"><code class="name">var <span class="ident">MetadataEntry</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.NORMALIZED_COUNTS"><code class="name">var <span class="ident">NORMALIZED_COUNTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.PCM"><code class="name">var <span class="ident">PCM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.PERCENTAGE"><code class="name">var <span class="ident">PERCENTAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.RADIANS"><code class="name">var <span class="ident">RADIANS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.RADIANS_PER_SECOND"><code class="name">var <span class="ident">RADIANS_PER_SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.SamplePayload"><code class="name">var <span class="ident">SamplePayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.Sensors"><code class="name">var <span class="ident">Sensors</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.StationInformation"><code class="name">var <span class="ident">StationInformation</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.SummaryStatistics"><code class="name">var <span class="ident">SummaryStatistics</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.TimingInformation"><code class="name">var <span class="ident">TimingInformation</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.TimingPayload"><code class="name">var <span class="ident">TimingPayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.UNITLESS"><code class="name">var <span class="ident">UNITLESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.Unit"><code class="name">var <span class="ident">Unit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="redvox.common.timesync.RedvoxPacketM.api"><code class="name">var <span class="ident">api</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.api</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.event_streams"><code class="name">var <span class="ident">event_streams</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.event_streams</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.metadata</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.sensors"><code class="name">var <span class="ident">sensors</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.sensors</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.station_information"><code class="name">var <span class="ident">station_information</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.station_information</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.sub_api"><code class="name">var <span class="ident">sub_api</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.sub_api</p></div>
</dd>
<dt id="redvox.common.timesync.RedvoxPacketM.timing_information"><code class="name">var <span class="ident">timing_information</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.timing_information</p></div>
</dd>
</dl>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis"><code class="flex name class">
<span>class <span class="ident">TimeSyncAnalysis</span></span>
<span>(</span><span>station_id: str = '', audio_sample_rate_hz: float = nan, station_start_timestamp: float = nan, time_sync_data: Optional[List[<a title="redvox.common.timesync.TimeSyncData" href="#redvox.common.timesync.TimeSyncData">TimeSyncData</a>]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Used for multiple TimeSyncData objects from a station
properties:
station_id: string, the station_id of the station being analyzed, default empty string
best_latency_index: int, the index of the TimeSyncData object with the best latency, default np.nan
latency_stats: StatsContainer, the statistics of the latencies
offset_stats: StatsContainer, the statistics of the offsets
offset_model: optional OffsetModel, used to calculate offset at a given point in time
sample_rate_hz: float, the audio sample rate in hz of the station, default np.nan
timesync_data: list of TimeSyncData, the TimeSyncData to analyze, default empty list
station_start_timestamp: float, the timestamp of when the station became active, default np.nan</p>
<p>Initialize the object
:param station_id: id of the station to analyze, default empty string
:param audio_sample_rate_hz: audio sample rate in hz of the station, default np.nan
:param station_start_timestamp: timestamp of when station started recording, default np.nan
:param time_sync_data: the TimeSyncData objects created from the packets of the station, default None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeSyncAnalysis:
    &#34;&#34;&#34;
    Used for multiple TimeSyncData objects from a station
    properties:
        station_id: string, the station_id of the station being analyzed, default empty string
        best_latency_index: int, the index of the TimeSyncData object with the best latency, default np.nan
        latency_stats: StatsContainer, the statistics of the latencies
        offset_stats: StatsContainer, the statistics of the offsets
        offset_model: optional OffsetModel, used to calculate offset at a given point in time
        sample_rate_hz: float, the audio sample rate in hz of the station, default np.nan
        timesync_data: list of TimeSyncData, the TimeSyncData to analyze, default empty list
        station_start_timestamp: float, the timestamp of when the station became active, default np.nan
    &#34;&#34;&#34;

    def __init__(
            self,
            station_id: str = &#34;&#34;,
            audio_sample_rate_hz: float = np.nan,
            station_start_timestamp: float = np.nan,
            time_sync_data: Optional[List[TimeSyncData]] = None,
    ):
        &#34;&#34;&#34;
        Initialize the object
        :param station_id: id of the station to analyze, default empty string
        :param audio_sample_rate_hz: audio sample rate in hz of the station, default np.nan
        :param station_start_timestamp: timestamp of when station started recording, default np.nan
        :param time_sync_data: the TimeSyncData objects created from the packets of the station, default None
        &#34;&#34;&#34;
        self.station_id: str = station_id
        self.sample_rate_hz: float = audio_sample_rate_hz
        self.station_start_timestamp: float = station_start_timestamp
        self.best_latency_index: int = np.nan
        self.latency_stats = sh.StatsContainer(&#34;latency&#34;)
        self.offset_stats = sh.StatsContainer(&#34;offset&#34;)
        self.errors = RedVoxExceptions(&#34;TimeSyncAnalysis&#34;)
        if time_sync_data:
            self.timesync_data: List[TimeSyncData] = time_sync_data
            self.evaluate_and_validate_data()
        else:
            self.timesync_data = []
            self.offset_model = OffsetModel.empty_model()

    def evaluate_and_validate_data(self):
        &#34;&#34;&#34;
        check the data for errors and update the analysis statistics
        &#34;&#34;&#34;
        self.evaluate_latencies()
        self.validate_start_timestamp()
        self.validate_sample_rate()
        self._calc_timesync_stats()
        self.offset_model = self.get_offset_model()

    def get_offset_model(self) -&gt; OffsetModel:
        &#34;&#34;&#34;
        :return: an OffsetModel based on the information in the timesync analysis
        &#34;&#34;&#34;
        return OffsetModel(self.get_latencies(), self.get_offsets(),
                           np.array([td.get_best_latency_timestamp() for td in self.timesync_data]),
                           self.timesync_data[0].packet_start_timestamp,
                           self.timesync_data[-1].packet_end_timestamp)

    def _calc_timesync_stats(self):
        &#34;&#34;&#34;
        calculates the mean and std deviation for latencies and offsets
        &#34;&#34;&#34;
        if len(self.timesync_data) &lt; 1:
            self.errors.append(
                &#34;Nothing to calculate stats; length of timesync data is less than 1&#34;
            )
        else:
            for index in range(len(self.timesync_data)):
                # add the stats of the latency
                self.latency_stats.add(
                    self.timesync_data[index].mean_latency,
                    self.timesync_data[index].latency_std,
                    self.timesync_data[index].num_tri_messages() * 2,
                    )
                # add the stats of the offset
                self.offset_stats.add(
                    self.timesync_data[index].mean_offset,
                    self.timesync_data[index].offset_std,
                    self.timesync_data[index].num_tri_messages() * 2,
                    )
            self.latency_stats.best_value = self.get_best_latency()
            self.offset_stats.best_value = self.get_best_offset()

    def from_packets(self, packets: List[Union[WrappedRedvoxPacketM, WrappedRedvoxPacket]]) -&gt; &#39;TimeSyncAnalysis&#39;:
        &#34;&#34;&#34;
        converts packets into TimeSyncData objects, then performs analysis
        :param packets: list of WrappedRedvoxPacketM to convert
        :return: modified version of self
        &#34;&#34;&#34;
        self.timesync_data = [TimeSyncData(self.station_id,
                                           self.sample_rate_hz,
                                           packet.get_sensors().get_audio().get_num_samples(),
                                           self.station_start_timestamp,
                                           packet.get_timing_information().get_server_acquisition_arrival_timestamp(),
                                           packet.get_timing_information().get_packet_start_mach_timestamp(),
                                           packet.get_timing_information().get_packet_end_mach_timestamp(),
                                           packet.get_timing_information().get_synch_exchange_array(),
                                           packet.get_timing_information().get_best_latency(),
                                           packet.get_timing_information().get_best_offset(),
                                           )
                              if isinstance(packet, WrappedRedvoxPacketM) else
                              TimeSyncData(self.station_id,
                                           self.sample_rate_hz,
                                           packet.microphone_sensor().payload_values().size,
                                           self.station_start_timestamp,
                                           packet.server_timestamp_epoch_microseconds_utc(),
                                           packet.start_timestamp_us_utc(),
                                           packet.end_timestamp_us_utc(),
                                           list(packet.time_synchronization_sensor().payload_values()),
                                           packet.best_latency(),
                                           packet.best_offset(),
                                           )
                              for packet in packets]
        if len(self.timesync_data) &gt; 0:
            self.evaluate_and_validate_data()
        return self

    def from_raw_packets(self, packets: List[Union[RedvoxPacketM, RedvoxPacket]]) -&gt; &#39;TimeSyncAnalysis&#39;:
        &#34;&#34;&#34;
        converts packets into TimeSyncData objects, then performs analysis
        :param packets: list of WrappedRedvoxPacketM to convert
        :return: modified version of self
        &#34;&#34;&#34;
        timesync_data: List[TimeSyncData] = []

        packet: Union[RedvoxPacketM, RedvoxPacket]
        for packet in packets:
            tsd: TimeSyncData
            if isinstance(packet, RedvoxPacketM):
                exchanges: List[float] = reduce(lambda acc, ex: acc + [ex.a1, ex.a2, ex.a3, ex.b1, ex.b2, ex.b3],
                                                packet.timing_information.synch_exchanges,
                                                [])
                tsd = TimeSyncData(
                    packet.station_information.id,
                    packet.sensors.audio.sample_rate,
                    len(packet.sensors.audio.samples.values),
                    packet.timing_information.app_start_mach_timestamp,
                    packet.timing_information.server_acquisition_arrival_timestamp,
                    packet.timing_information.packet_start_mach_timestamp,
                    packet.timing_information.packet_end_mach_timestamp,
                    exchanges,
                    packet.timing_information.best_latency,
                    packet.timing_information.best_offset
                )
            else:
                mtz: float = np.nan
                best_latency: float = np.nan
                best_offset: float = np.nan

                for i, v in enumerate(packet.metadata):
                    plus_1: int = i + 1
                    try:
                        if v == &#34;machTimeZero&#34; and plus_1 &lt; len(packet.metadata):
                            mtz = float(packet.metadata[plus_1])
                        if v == &#34;bestLatency&#34; and plus_1 &lt; len(packet.metadata):
                            best_latency = float(packet.metadata[plus_1])
                        if v == &#34;bestOffset&#34; and plus_1 &lt; len(packet.metadata):
                            best_offset = float(packet.metadata[plus_1])
                    except (KeyError, ValueError):
                        continue

                # Get synch exchanges
                exchanges: Optional[np.ndarray] = None
                ch: api900_pb2.UnevenlySampledChannel
                for ch in packet.unevenly_sampled_channels:
                    if api900_pb2.TIME_SYNCHRONIZATION in ch.channel_types:
                        exchanges = util_900.extract_payload(ch)

                tsd = TimeSyncData(
                    packet.redvox_id,
                    packet.evenly_sampled_channels[0].sample_rate_hz,
                    util_900.payload_len(packet.evenly_sampled_channels[0]),
                    mtz,
                    packet.evenly_sampled_channels[0].first_sample_timestamp_epoch_microseconds_utc,
                    packet.server_timestamp_epoch_microseconds_utc,
                    packet.app_file_start_timestamp_machine,
                    list(exchanges),
                    best_latency,
                    best_offset,
                )

            timesync_data.append(tsd)

        self.timesync_data = timesync_data

        if len(self.timesync_data) &gt; 0:
            self.evaluate_and_validate_data()

        return self

    def add_timesync_data(self, timesync_data: TimeSyncData):
        &#34;&#34;&#34;
        adds a TimeSyncData object to the analysis
        :param timesync_data: TimeSyncData to add
        &#34;&#34;&#34;
        self.timesync_data.append(timesync_data)
        self.evaluate_and_validate_data()

    def get_num_packets(self) -&gt; int:
        &#34;&#34;&#34;
        :return: number of packets analyzed
        &#34;&#34;&#34;
        return len(self.timesync_data)

    def get_best_latency(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].best_latency

    def get_latencies(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: np.array containing all the latencies
        &#34;&#34;&#34;
        return np.array([ts_data.best_latency for ts_data in self.timesync_data])

    def get_mean_latency(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the mean of the latencies, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.latency_stats.mean_of_means()

    def get_latency_stdev(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the standard deviation of the latencies, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.latency_stats.total_std_dev()

    def get_best_offset(self) -&gt; float:
        &#34;&#34;&#34;
        :return: offset associated with the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].best_offset

    def get_offsets(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: np.array containing all the offsets
        &#34;&#34;&#34;
        return np.array([ts_data.best_offset for ts_data in self.timesync_data])

    def get_mean_offset(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the mean of the offsets, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.offset_stats.mean_of_means()

    def get_offset_stdev(self) -&gt; float:
        &#34;&#34;&#34;
        :return: the standard deviation of the offsets, or np.nan if it doesn&#39;t exist
        &#34;&#34;&#34;
        return self.offset_stats.total_std_dev()

    def get_best_packet_latency_index(self) -&gt; int:
        &#34;&#34;&#34;
        :return: the best latency&#39;s index in the packet with the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].best_latency_index

    def get_best_start_time(self) -&gt; float:
        &#34;&#34;&#34;
        :return: start timestamp associated with the best latency
        &#34;&#34;&#34;
        if np.isnan(self.best_latency_index):
            return np.nan
        return self.timesync_data[self.best_latency_index].packet_start_timestamp

    def get_start_times(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: list of the start timestamps of each packet
        &#34;&#34;&#34;
        start_times = []
        for ts_data in self.timesync_data:
            start_times.append(ts_data.packet_start_timestamp)
        return np.array(start_times)

    def get_bad_packets(self) -&gt; List[int]:
        &#34;&#34;&#34;
        :return: list of all packets that contains invalid data
        &#34;&#34;&#34;
        bad_packets = []
        for idx in range(
                self.get_num_packets()
        ):  # mark bad indices (they have a 0 or less value)
            if self.get_latencies()[idx] &lt;= 0 or np.isnan(self.get_latencies()[idx]):
                bad_packets.append(idx)
        return bad_packets

    def evaluate_latencies(self):
        &#34;&#34;&#34;
        finds the best latency
        outputs warnings if a change in timestamps is detected
        &#34;&#34;&#34;
        if self.get_num_packets() &lt; 1:
            self.errors.append(
                &#34;Latencies cannot be evaluated; length of timesync data is less than 1&#34;
            )
        else:
            self.best_latency_index = 0
            # assume the first element has the best timesync values for now, then compare with the others
            for index in range(1, self.get_num_packets()):
                best_latency = self.get_best_latency()
                # find the best latency; in this case, the minimum
                # if new value exists and if the current best does not or new value is better than current best, update
                if (not np.isnan(self.timesync_data[index].best_latency) and (np.isnan(best_latency))
                        or self.timesync_data[index].best_latency &lt; best_latency):
                    self.best_latency_index = index

    def validate_start_timestamp(self, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        confirms if station_start_timestamp differs in any of the timesync_data
        outputs warnings if a change in timestamps is detected
        :param debug: if True, output warning message, default False
        :return: True if no change
        &#34;&#34;&#34;
        for index in range(self.get_num_packets()):
            # compare station start timestamps; notify when they are different
            if (
                    self.timesync_data[index].station_start_timestamp
                    != self.station_start_timestamp
            ):
                self.errors.append(
                    f&#34;Change in station start timestamp detected; &#34;
                    f&#34;expected: {self.station_start_timestamp}, read: &#34;
                    f&#34;{self.timesync_data[index].station_start_timestamp}&#34;
                )
                if debug:
                    self.errors.print()
                return False
        # if here, all the sample timestamps are the same
        return True

    def validate_sample_rate(self, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        confirms if sample rate is the same across all timesync_data
        outputs warning if a change in sample rate is detected
        :param debug: if True, output warning message, default False
        :return: True if no change
        &#34;&#34;&#34;
        for index in range(self.get_num_packets()):
            # compare station start timestamps; notify when they are different
            if (
                    np.isnan(self.timesync_data[index].sample_rate_hz)
                    or self.timesync_data[index].sample_rate_hz != self.sample_rate_hz
            ):
                self.errors.append(
                    f&#34;Change in station sample rate detected; &#34;
                    f&#34;expected: {self.sample_rate_hz}, read: {self.timesync_data[index].sample_rate_hz}&#34;
                )
                if debug:
                    self.errors.print()
                return False
        # if here, all the sample rates are the same
        return True

    def validate_time_gaps(self, gap_duration_s: float, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        confirms there are no data gaps between packets
        outputs warning if a gap is detected
        :param gap_duration_s: length of time in seconds to be detected as a gap
        :param debug: if True, output warning message, default False
        :return: True if no gap
        &#34;&#34;&#34;
        if self.get_num_packets() &lt; 2:
            self.errors.append(&#34;Less than 2 timesync data objects to evaluate gaps with&#34;)
            if debug:
                self.errors.print()
        else:
            for index in range(1, self.get_num_packets()):
                # compare last packet&#39;s end timestamp with current start timestamp
                if (
                        dt.microseconds_to_seconds(
                            self.timesync_data[index].packet_start_timestamp
                            - self.timesync_data[index - 1].packet_end_timestamp
                        )
                        &gt; gap_duration_s
                ):
                    self.errors.append(f&#34;Gap detected at packet number: {index}&#34;)
                    if debug:
                        self.errors.print()
                    return False
        # if here, no gaps
        return True

    def update_timestamps(self, use_model: bool = True):
        &#34;&#34;&#34;
        update timestamps by adding microseconds based on the OffsetModel.
        :param use_model: if True, use the model, otherwise use best offset
        &#34;&#34;&#34;
        if use_model and self.offset_model:
            self.station_start_timestamp += self.offset_model.get_offset_at_new_time(self.station_start_timestamp)
            for tsd in self.timesync_data:
                tsd.update_timestamps(self.offset_model)
        else:
            self.station_start_timestamp += self.get_best_offset()
            for tsd in self.timesync_data:
                tsd.update_timestamps()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.timesync.TimeSyncAnalysis.add_timesync_data"><code class="name flex">
<span>def <span class="ident">add_timesync_data</span></span>(<span>self, timesync_data: <a title="redvox.common.timesync.TimeSyncData" href="#redvox.common.timesync.TimeSyncData">TimeSyncData</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a TimeSyncData object to the analysis
:param timesync_data: TimeSyncData to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_timesync_data(self, timesync_data: TimeSyncData):
    &#34;&#34;&#34;
    adds a TimeSyncData object to the analysis
    :param timesync_data: TimeSyncData to add
    &#34;&#34;&#34;
    self.timesync_data.append(timesync_data)
    self.evaluate_and_validate_data()</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.evaluate_and_validate_data"><code class="name flex">
<span>def <span class="ident">evaluate_and_validate_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check the data for errors and update the analysis statistics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_and_validate_data(self):
    &#34;&#34;&#34;
    check the data for errors and update the analysis statistics
    &#34;&#34;&#34;
    self.evaluate_latencies()
    self.validate_start_timestamp()
    self.validate_sample_rate()
    self._calc_timesync_stats()
    self.offset_model = self.get_offset_model()</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.evaluate_latencies"><code class="name flex">
<span>def <span class="ident">evaluate_latencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>finds the best latency
outputs warnings if a change in timestamps is detected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_latencies(self):
    &#34;&#34;&#34;
    finds the best latency
    outputs warnings if a change in timestamps is detected
    &#34;&#34;&#34;
    if self.get_num_packets() &lt; 1:
        self.errors.append(
            &#34;Latencies cannot be evaluated; length of timesync data is less than 1&#34;
        )
    else:
        self.best_latency_index = 0
        # assume the first element has the best timesync values for now, then compare with the others
        for index in range(1, self.get_num_packets()):
            best_latency = self.get_best_latency()
            # find the best latency; in this case, the minimum
            # if new value exists and if the current best does not or new value is better than current best, update
            if (not np.isnan(self.timesync_data[index].best_latency) and (np.isnan(best_latency))
                    or self.timesync_data[index].best_latency &lt; best_latency):
                self.best_latency_index = index</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.from_packets"><code class="name flex">
<span>def <span class="ident">from_packets</span></span>(<span>self, packets: List[Union[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>, <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="../api900/wrapped_redvox_packet.html#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a>]]) ‑> <a title="redvox.common.timesync.TimeSyncAnalysis" href="#redvox.common.timesync.TimeSyncAnalysis">TimeSyncAnalysis</a></span>
</code></dt>
<dd>
<div class="desc"><p>converts packets into TimeSyncData objects, then performs analysis
:param packets: list of WrappedRedvoxPacketM to convert
:return: modified version of self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_packets(self, packets: List[Union[WrappedRedvoxPacketM, WrappedRedvoxPacket]]) -&gt; &#39;TimeSyncAnalysis&#39;:
    &#34;&#34;&#34;
    converts packets into TimeSyncData objects, then performs analysis
    :param packets: list of WrappedRedvoxPacketM to convert
    :return: modified version of self
    &#34;&#34;&#34;
    self.timesync_data = [TimeSyncData(self.station_id,
                                       self.sample_rate_hz,
                                       packet.get_sensors().get_audio().get_num_samples(),
                                       self.station_start_timestamp,
                                       packet.get_timing_information().get_server_acquisition_arrival_timestamp(),
                                       packet.get_timing_information().get_packet_start_mach_timestamp(),
                                       packet.get_timing_information().get_packet_end_mach_timestamp(),
                                       packet.get_timing_information().get_synch_exchange_array(),
                                       packet.get_timing_information().get_best_latency(),
                                       packet.get_timing_information().get_best_offset(),
                                       )
                          if isinstance(packet, WrappedRedvoxPacketM) else
                          TimeSyncData(self.station_id,
                                       self.sample_rate_hz,
                                       packet.microphone_sensor().payload_values().size,
                                       self.station_start_timestamp,
                                       packet.server_timestamp_epoch_microseconds_utc(),
                                       packet.start_timestamp_us_utc(),
                                       packet.end_timestamp_us_utc(),
                                       list(packet.time_synchronization_sensor().payload_values()),
                                       packet.best_latency(),
                                       packet.best_offset(),
                                       )
                          for packet in packets]
    if len(self.timesync_data) &gt; 0:
        self.evaluate_and_validate_data()
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.from_raw_packets"><code class="name flex">
<span>def <span class="ident">from_raw_packets</span></span>(<span>self, packets: List[Union[src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM, api900_pb2.RedvoxPacket]]) ‑> <a title="redvox.common.timesync.TimeSyncAnalysis" href="#redvox.common.timesync.TimeSyncAnalysis">TimeSyncAnalysis</a></span>
</code></dt>
<dd>
<div class="desc"><p>converts packets into TimeSyncData objects, then performs analysis
:param packets: list of WrappedRedvoxPacketM to convert
:return: modified version of self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_raw_packets(self, packets: List[Union[RedvoxPacketM, RedvoxPacket]]) -&gt; &#39;TimeSyncAnalysis&#39;:
    &#34;&#34;&#34;
    converts packets into TimeSyncData objects, then performs analysis
    :param packets: list of WrappedRedvoxPacketM to convert
    :return: modified version of self
    &#34;&#34;&#34;
    timesync_data: List[TimeSyncData] = []

    packet: Union[RedvoxPacketM, RedvoxPacket]
    for packet in packets:
        tsd: TimeSyncData
        if isinstance(packet, RedvoxPacketM):
            exchanges: List[float] = reduce(lambda acc, ex: acc + [ex.a1, ex.a2, ex.a3, ex.b1, ex.b2, ex.b3],
                                            packet.timing_information.synch_exchanges,
                                            [])
            tsd = TimeSyncData(
                packet.station_information.id,
                packet.sensors.audio.sample_rate,
                len(packet.sensors.audio.samples.values),
                packet.timing_information.app_start_mach_timestamp,
                packet.timing_information.server_acquisition_arrival_timestamp,
                packet.timing_information.packet_start_mach_timestamp,
                packet.timing_information.packet_end_mach_timestamp,
                exchanges,
                packet.timing_information.best_latency,
                packet.timing_information.best_offset
            )
        else:
            mtz: float = np.nan
            best_latency: float = np.nan
            best_offset: float = np.nan

            for i, v in enumerate(packet.metadata):
                plus_1: int = i + 1
                try:
                    if v == &#34;machTimeZero&#34; and plus_1 &lt; len(packet.metadata):
                        mtz = float(packet.metadata[plus_1])
                    if v == &#34;bestLatency&#34; and plus_1 &lt; len(packet.metadata):
                        best_latency = float(packet.metadata[plus_1])
                    if v == &#34;bestOffset&#34; and plus_1 &lt; len(packet.metadata):
                        best_offset = float(packet.metadata[plus_1])
                except (KeyError, ValueError):
                    continue

            # Get synch exchanges
            exchanges: Optional[np.ndarray] = None
            ch: api900_pb2.UnevenlySampledChannel
            for ch in packet.unevenly_sampled_channels:
                if api900_pb2.TIME_SYNCHRONIZATION in ch.channel_types:
                    exchanges = util_900.extract_payload(ch)

            tsd = TimeSyncData(
                packet.redvox_id,
                packet.evenly_sampled_channels[0].sample_rate_hz,
                util_900.payload_len(packet.evenly_sampled_channels[0]),
                mtz,
                packet.evenly_sampled_channels[0].first_sample_timestamp_epoch_microseconds_utc,
                packet.server_timestamp_epoch_microseconds_utc,
                packet.app_file_start_timestamp_machine,
                list(exchanges),
                best_latency,
                best_offset,
            )

        timesync_data.append(tsd)

    self.timesync_data = timesync_data

    if len(self.timesync_data) &gt; 0:
        self.evaluate_and_validate_data()

    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_bad_packets"><code class="name flex">
<span>def <span class="ident">get_bad_packets</span></span>(<span>self) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: list of all packets that contains invalid data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bad_packets(self) -&gt; List[int]:
    &#34;&#34;&#34;
    :return: list of all packets that contains invalid data
    &#34;&#34;&#34;
    bad_packets = []
    for idx in range(
            self.get_num_packets()
    ):  # mark bad indices (they have a 0 or less value)
        if self.get_latencies()[idx] &lt;= 0 or np.isnan(self.get_latencies()[idx]):
            bad_packets.append(idx)
    return bad_packets</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_best_latency"><code class="name flex">
<span>def <span class="ident">get_best_latency</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the best latency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_latency(self) -&gt; float:
    &#34;&#34;&#34;
    :return: the best latency
    &#34;&#34;&#34;
    if np.isnan(self.best_latency_index):
        return np.nan
    return self.timesync_data[self.best_latency_index].best_latency</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_best_offset"><code class="name flex">
<span>def <span class="ident">get_best_offset</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: offset associated with the best latency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_offset(self) -&gt; float:
    &#34;&#34;&#34;
    :return: offset associated with the best latency
    &#34;&#34;&#34;
    if np.isnan(self.best_latency_index):
        return np.nan
    return self.timesync_data[self.best_latency_index].best_offset</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_best_packet_latency_index"><code class="name flex">
<span>def <span class="ident">get_best_packet_latency_index</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the best latency's index in the packet with the best latency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_packet_latency_index(self) -&gt; int:
    &#34;&#34;&#34;
    :return: the best latency&#39;s index in the packet with the best latency
    &#34;&#34;&#34;
    if np.isnan(self.best_latency_index):
        return np.nan
    return self.timesync_data[self.best_latency_index].best_latency_index</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_best_start_time"><code class="name flex">
<span>def <span class="ident">get_best_start_time</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: start timestamp associated with the best latency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_start_time(self) -&gt; float:
    &#34;&#34;&#34;
    :return: start timestamp associated with the best latency
    &#34;&#34;&#34;
    if np.isnan(self.best_latency_index):
        return np.nan
    return self.timesync_data[self.best_latency_index].packet_start_timestamp</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_latencies"><code class="name flex">
<span>def <span class="ident">get_latencies</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: np.array containing all the latencies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latencies(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: np.array containing all the latencies
    &#34;&#34;&#34;
    return np.array([ts_data.best_latency for ts_data in self.timesync_data])</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_latency_stdev"><code class="name flex">
<span>def <span class="ident">get_latency_stdev</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the standard deviation of the latencies, or np.nan if it doesn't exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latency_stdev(self) -&gt; float:
    &#34;&#34;&#34;
    :return: the standard deviation of the latencies, or np.nan if it doesn&#39;t exist
    &#34;&#34;&#34;
    return self.latency_stats.total_std_dev()</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_mean_latency"><code class="name flex">
<span>def <span class="ident">get_mean_latency</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the mean of the latencies, or np.nan if it doesn't exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean_latency(self) -&gt; float:
    &#34;&#34;&#34;
    :return: the mean of the latencies, or np.nan if it doesn&#39;t exist
    &#34;&#34;&#34;
    return self.latency_stats.mean_of_means()</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_mean_offset"><code class="name flex">
<span>def <span class="ident">get_mean_offset</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the mean of the offsets, or np.nan if it doesn't exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean_offset(self) -&gt; float:
    &#34;&#34;&#34;
    :return: the mean of the offsets, or np.nan if it doesn&#39;t exist
    &#34;&#34;&#34;
    return self.offset_stats.mean_of_means()</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_num_packets"><code class="name flex">
<span>def <span class="ident">get_num_packets</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>:return: number of packets analyzed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_packets(self) -&gt; int:
    &#34;&#34;&#34;
    :return: number of packets analyzed
    &#34;&#34;&#34;
    return len(self.timesync_data)</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_offset_model"><code class="name flex">
<span>def <span class="ident">get_offset_model</span></span>(<span>self) ‑> <a title="redvox.common.offset_model.OffsetModel" href="offset_model.html#redvox.common.offset_model.OffsetModel">OffsetModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: an OffsetModel based on the information in the timesync analysis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset_model(self) -&gt; OffsetModel:
    &#34;&#34;&#34;
    :return: an OffsetModel based on the information in the timesync analysis
    &#34;&#34;&#34;
    return OffsetModel(self.get_latencies(), self.get_offsets(),
                       np.array([td.get_best_latency_timestamp() for td in self.timesync_data]),
                       self.timesync_data[0].packet_start_timestamp,
                       self.timesync_data[-1].packet_end_timestamp)</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_offset_stdev"><code class="name flex">
<span>def <span class="ident">get_offset_stdev</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the standard deviation of the offsets, or np.nan if it doesn't exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset_stdev(self) -&gt; float:
    &#34;&#34;&#34;
    :return: the standard deviation of the offsets, or np.nan if it doesn&#39;t exist
    &#34;&#34;&#34;
    return self.offset_stats.total_std_dev()</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_offsets"><code class="name flex">
<span>def <span class="ident">get_offsets</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: np.array containing all the offsets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offsets(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: np.array containing all the offsets
    &#34;&#34;&#34;
    return np.array([ts_data.best_offset for ts_data in self.timesync_data])</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.get_start_times"><code class="name flex">
<span>def <span class="ident">get_start_times</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: list of the start timestamps of each packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_times(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: list of the start timestamps of each packet
    &#34;&#34;&#34;
    start_times = []
    for ts_data in self.timesync_data:
        start_times.append(ts_data.packet_start_timestamp)
    return np.array(start_times)</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.update_timestamps"><code class="name flex">
<span>def <span class="ident">update_timestamps</span></span>(<span>self, use_model: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>update timestamps by adding microseconds based on the OffsetModel.
:param use_model: if True, use the model, otherwise use best offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_timestamps(self, use_model: bool = True):
    &#34;&#34;&#34;
    update timestamps by adding microseconds based on the OffsetModel.
    :param use_model: if True, use the model, otherwise use best offset
    &#34;&#34;&#34;
    if use_model and self.offset_model:
        self.station_start_timestamp += self.offset_model.get_offset_at_new_time(self.station_start_timestamp)
        for tsd in self.timesync_data:
            tsd.update_timestamps(self.offset_model)
    else:
        self.station_start_timestamp += self.get_best_offset()
        for tsd in self.timesync_data:
            tsd.update_timestamps()</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.validate_sample_rate"><code class="name flex">
<span>def <span class="ident">validate_sample_rate</span></span>(<span>self, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>confirms if sample rate is the same across all timesync_data
outputs warning if a change in sample rate is detected
:param debug: if True, output warning message, default False
:return: True if no change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_sample_rate(self, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    confirms if sample rate is the same across all timesync_data
    outputs warning if a change in sample rate is detected
    :param debug: if True, output warning message, default False
    :return: True if no change
    &#34;&#34;&#34;
    for index in range(self.get_num_packets()):
        # compare station start timestamps; notify when they are different
        if (
                np.isnan(self.timesync_data[index].sample_rate_hz)
                or self.timesync_data[index].sample_rate_hz != self.sample_rate_hz
        ):
            self.errors.append(
                f&#34;Change in station sample rate detected; &#34;
                f&#34;expected: {self.sample_rate_hz}, read: {self.timesync_data[index].sample_rate_hz}&#34;
            )
            if debug:
                self.errors.print()
            return False
    # if here, all the sample rates are the same
    return True</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.validate_start_timestamp"><code class="name flex">
<span>def <span class="ident">validate_start_timestamp</span></span>(<span>self, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>confirms if station_start_timestamp differs in any of the timesync_data
outputs warnings if a change in timestamps is detected
:param debug: if True, output warning message, default False
:return: True if no change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_start_timestamp(self, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    confirms if station_start_timestamp differs in any of the timesync_data
    outputs warnings if a change in timestamps is detected
    :param debug: if True, output warning message, default False
    :return: True if no change
    &#34;&#34;&#34;
    for index in range(self.get_num_packets()):
        # compare station start timestamps; notify when they are different
        if (
                self.timesync_data[index].station_start_timestamp
                != self.station_start_timestamp
        ):
            self.errors.append(
                f&#34;Change in station start timestamp detected; &#34;
                f&#34;expected: {self.station_start_timestamp}, read: &#34;
                f&#34;{self.timesync_data[index].station_start_timestamp}&#34;
            )
            if debug:
                self.errors.print()
            return False
    # if here, all the sample timestamps are the same
    return True</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncAnalysis.validate_time_gaps"><code class="name flex">
<span>def <span class="ident">validate_time_gaps</span></span>(<span>self, gap_duration_s: float, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>confirms there are no data gaps between packets
outputs warning if a gap is detected
:param gap_duration_s: length of time in seconds to be detected as a gap
:param debug: if True, output warning message, default False
:return: True if no gap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_time_gaps(self, gap_duration_s: float, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    confirms there are no data gaps between packets
    outputs warning if a gap is detected
    :param gap_duration_s: length of time in seconds to be detected as a gap
    :param debug: if True, output warning message, default False
    :return: True if no gap
    &#34;&#34;&#34;
    if self.get_num_packets() &lt; 2:
        self.errors.append(&#34;Less than 2 timesync data objects to evaluate gaps with&#34;)
        if debug:
            self.errors.print()
    else:
        for index in range(1, self.get_num_packets()):
            # compare last packet&#39;s end timestamp with current start timestamp
            if (
                    dt.microseconds_to_seconds(
                        self.timesync_data[index].packet_start_timestamp
                        - self.timesync_data[index - 1].packet_end_timestamp
                    )
                    &gt; gap_duration_s
            ):
                self.errors.append(f&#34;Gap detected at packet number: {index}&#34;)
                if debug:
                    self.errors.print()
                return False
    # if here, no gaps
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.timesync.TimeSyncData"><code class="flex name class">
<span>class <span class="ident">TimeSyncData</span></span>
<span>(</span><span>station_id: str = '', sample_rate_hz: float = nan, num_audio_samples: int = nan, station_start_timestamp: float = nan, server_acquisition_timestamp: float = nan, packet_start_timestamp: float = nan, packet_end_timestamp: float = nan, time_sync_exchanges_list: Optional[List[float]] = None, best_latency: float = nan, best_offset: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores latencies, offsets, and other timesync related information about a single station
ALL timestamps in microseconds unless otherwise stated
properties:
station_id: str, id of station, default empty string
station_start_timestamp: float, timestamp of when the station was started, default np.nan
sample_rate_hz: float, sample rate of audio sensor in Hz, default np.nan
packet_start_timestamp: float, timestamp of when data started recording, default np.nan
packet_end_timestamp: float, timestamp of when data stopped recording, default np.nan
packet_duration: float, length of packet in microseconds, default 0.0
server_acquisition_timestamp: float, timestamp of when packet arrived at server, default np.nan
time_sync_exchanges_df: dataframe, timestamps that form the time synch exchanges, default empty dataframe
latencies: np.ndarray, calculated latencies of the exchanges, default empty np.ndarray
best_latency_index: int, index in latencies array that contains the best latency, default np.nan
best_latency: float, best latency of the data, default np.nan
mean_latency: float, mean latency, default np.nan
latency_std: float, standard deviation of latencies, default np.nan
offsets: np.ndarray, calculated offsets of the exchanges, default np.ndarray
best_offset: float, best offset of the data, default np.nan
mean_offset: float, mean offset, default np.nan
offset_std: float, standard deviation of offsets, default np.nan
best_tri_msg_index: int, index of the best tri-message (same as best_latency_index), default np.nan
best_msg_timestamp_index: int = np.nan, 1 or 3, indicates which tri-message latency array has the best latency
acquire_travel_time: float, calculated time it took packet to reach server, default np.nan</p>
<p>Initialize properties
:param station_id: id of station, default empty string
:param sample_rate_hz: sample rate in hz of the station's audio channel, default np.nan
:param num_audio_samples: number of audio samples in the data, default np.nan
:param station_start_timestamp: timestamp of when the station started recording, default np.nan
:param server_acquisition_timestamp: timestamp of when the data was received at the acquisition server,
default np.nan
:param packet_start_timestamp: timestamp of the start of the data packet, default np.nan
:param packet_end_timestamp: timestamp of the end of the data packet, default np.nan
:param time_sync_exchanges_list: the timesync exchanges of the packet as a flat list, default None
:param best_latency: the best latency of the packet, default np.nan
:param best_offset: the best offset of the packet, default 0.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeSyncData:
    &#34;&#34;&#34;
    Stores latencies, offsets, and other timesync related information about a single station
    ALL timestamps in microseconds unless otherwise stated
    properties:
        station_id: str, id of station, default empty string
        station_start_timestamp: float, timestamp of when the station was started, default np.nan
        sample_rate_hz: float, sample rate of audio sensor in Hz, default np.nan
        packet_start_timestamp: float, timestamp of when data started recording, default np.nan
        packet_end_timestamp: float, timestamp of when data stopped recording, default np.nan
        packet_duration: float, length of packet in microseconds, default 0.0
        server_acquisition_timestamp: float, timestamp of when packet arrived at server, default np.nan
        time_sync_exchanges_df: dataframe, timestamps that form the time synch exchanges, default empty dataframe
        latencies: np.ndarray, calculated latencies of the exchanges, default empty np.ndarray
        best_latency_index: int, index in latencies array that contains the best latency, default np.nan
        best_latency: float, best latency of the data, default np.nan
        mean_latency: float, mean latency, default np.nan
        latency_std: float, standard deviation of latencies, default np.nan
        offsets: np.ndarray, calculated offsets of the exchanges, default np.ndarray
        best_offset: float, best offset of the data, default np.nan
        mean_offset: float, mean offset, default np.nan
        offset_std: float, standard deviation of offsets, default np.nan
        best_tri_msg_index: int, index of the best tri-message (same as best_latency_index), default np.nan
        best_msg_timestamp_index: int = np.nan, 1 or 3, indicates which tri-message latency array has the best latency
        acquire_travel_time: float, calculated time it took packet to reach server, default np.nan
    &#34;&#34;&#34;

    def __init__(
            self,
            station_id: str = &#34;&#34;,
            sample_rate_hz: float = np.nan,
            num_audio_samples: int = np.nan,
            station_start_timestamp: float = np.nan,
            server_acquisition_timestamp: float = np.nan,
            packet_start_timestamp: float = np.nan,
            packet_end_timestamp: float = np.nan,
            time_sync_exchanges_list: Optional[List[float]] = None,
            best_latency: float = np.nan,
            best_offset: float = 0.0,
    ):
        &#34;&#34;&#34;
        Initialize properties
        :param station_id: id of station, default empty string
        :param sample_rate_hz: sample rate in hz of the station&#39;s audio channel, default np.nan
        :param num_audio_samples: number of audio samples in the data, default np.nan
        :param station_start_timestamp: timestamp of when the station started recording, default np.nan
        :param server_acquisition_timestamp: timestamp of when the data was received at the acquisition server,
                                                default np.nan
        :param packet_start_timestamp: timestamp of the start of the data packet, default np.nan
        :param packet_end_timestamp: timestamp of the end of the data packet, default np.nan
        :param time_sync_exchanges_list: the timesync exchanges of the packet as a flat list, default None
        :param best_latency: the best latency of the packet, default np.nan
        :param best_offset: the best offset of the packet, default 0.0
        &#34;&#34;&#34;
        self.station_id = station_id
        self.sample_rate_hz = sample_rate_hz
        self.num_audio_samples = num_audio_samples
        self.station_start_timestamp = station_start_timestamp
        self.server_acquisition_timestamp = server_acquisition_timestamp
        self.packet_start_timestamp = packet_start_timestamp
        self.packet_end_timestamp = packet_end_timestamp
        if time_sync_exchanges_list is None:
            time_sync_exchanges_list = []
        else:
            time_sync_exchanges_list = [
                time_sync_exchanges_list[i: i + 6]
                for i in range(0, len(time_sync_exchanges_list), 6)
            ]
        self.time_sync_exchanges_list = np.transpose(time_sync_exchanges_list)
        self.best_latency = best_latency
        self.best_offset = best_offset

        self._compute_tri_message_stats()
        # set the packet duration
        self.packet_duration = self.packet_end_timestamp - self.packet_start_timestamp
        # calculate travel time between corrected end of packet timestamp and server timestamp
        self.acquire_travel_time = self.server_acquisition_timestamp - (
                self.packet_end_timestamp + self.best_offset
        )

    def _compute_tri_message_stats(self):
        &#34;&#34;&#34;
        Compute the tri-message stats from the data
        &#34;&#34;&#34;
        if self.num_tri_messages() &gt; 0:
            # compute tri message data from time sync exchanges
            tse = tms.TriMessageStats(
                self.station_id,
                np.array(self.time_sync_exchanges_list[0]),
                np.array(self.time_sync_exchanges_list[1]),
                np.array(self.time_sync_exchanges_list[2]),
                np.array(self.time_sync_exchanges_list[3]),
                np.array(self.time_sync_exchanges_list[4]),
                np.array(self.time_sync_exchanges_list[5]),
            )
            # Compute the statistics for latency and offset
            self.mean_latency = np.mean([*tse.latency1, *tse.latency3])
            self.latency_std = np.std([*tse.latency1, *tse.latency3])
            self.mean_offset = np.mean([*tse.offset1, *tse.offset3])
            self.offset_std = np.std([*tse.offset1, *tse.offset3])
            self.latencies = np.array((tse.latency1, tse.latency3))
            self.offsets = np.array((tse.offset1, tse.offset3))
            self.best_latency_index = tse.best_latency_index
            self.best_tri_msg_index = tse.best_latency_index
            self.best_msg_timestamp_index = tse.best_latency_array_index
            # if best_latency is np.nan, set to best computed latency
            if np.isnan(self.best_latency):
                self.best_latency = tse.best_latency
                self.best_offset = tse.best_offset
            # if best_offset is still default value, use the best computed offset
            elif self.best_offset == 0:
                self.best_offset = tse.best_offset
        else:
            # If here, there are no exchanges to read.  write default or empty values to the correct properties
            self.best_tri_msg_index = np.nan
            self.best_latency_index = np.nan
            self.best_latency = np.nan
            self.mean_latency = np.nan
            self.latency_std = np.nan
            self.best_offset = 0
            self.mean_offset = 0
            self.offset_std = 0
            self.best_msg_timestamp_index = np.nan

    def num_tri_messages(self) -&gt; int:
        &#34;&#34;&#34;
        return the number of tri-message exchanges
        :return: number of tri-message exchanges
        &#34;&#34;&#34;
        return np.size(self.time_sync_exchanges_list, 0)

    def update_timestamps(self, om: Optional[OffsetModel]):
        &#34;&#34;&#34;
        update timestamps by adding microseconds based on the OffsetModel.
        if model not supplied, uses the best offset.
        uses negative values to go backwards in time
        :param om: OffsetModel to calculate offsets, default None
        &#34;&#34;&#34;
        if not om:
            delta = self.best_offset
            self.station_start_timestamp += delta
            self.packet_start_timestamp += delta
            self.packet_end_timestamp += delta
        else:
            self.station_start_timestamp = om.update_time(self.station_start_timestamp)
            self.packet_start_timestamp = om.update_time(self.packet_start_timestamp)
            self.packet_end_timestamp = om.update_time(self.packet_end_timestamp)

    def get_best_latency_timestamp(self) -&gt; float:
        &#34;&#34;&#34;
        :return: timestamp of best latency, or start of the packet if no best latency.
        &#34;&#34;&#34;
        if self.best_msg_timestamp_index == 1:
            return self.time_sync_exchanges_list[3][self.best_latency_index]
        elif self.best_msg_timestamp_index == 3:
            return self.time_sync_exchanges_list[5][self.best_latency_index]
        else:
            return self.packet_start_timestamp</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.timesync.TimeSyncData.get_best_latency_timestamp"><code class="name flex">
<span>def <span class="ident">get_best_latency_timestamp</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: timestamp of best latency, or start of the packet if no best latency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_latency_timestamp(self) -&gt; float:
    &#34;&#34;&#34;
    :return: timestamp of best latency, or start of the packet if no best latency.
    &#34;&#34;&#34;
    if self.best_msg_timestamp_index == 1:
        return self.time_sync_exchanges_list[3][self.best_latency_index]
    elif self.best_msg_timestamp_index == 3:
        return self.time_sync_exchanges_list[5][self.best_latency_index]
    else:
        return self.packet_start_timestamp</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncData.num_tri_messages"><code class="name flex">
<span>def <span class="ident">num_tri_messages</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>return the number of tri-message exchanges
:return: number of tri-message exchanges</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_tri_messages(self) -&gt; int:
    &#34;&#34;&#34;
    return the number of tri-message exchanges
    :return: number of tri-message exchanges
    &#34;&#34;&#34;
    return np.size(self.time_sync_exchanges_list, 0)</code></pre>
</details>
</dd>
<dt id="redvox.common.timesync.TimeSyncData.update_timestamps"><code class="name flex">
<span>def <span class="ident">update_timestamps</span></span>(<span>self, om: Optional[<a title="redvox.common.offset_model.OffsetModel" href="offset_model.html#redvox.common.offset_model.OffsetModel">OffsetModel</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>update timestamps by adding microseconds based on the OffsetModel.
if model not supplied, uses the best offset.
uses negative values to go backwards in time
:param om: OffsetModel to calculate offsets, default None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_timestamps(self, om: Optional[OffsetModel]):
    &#34;&#34;&#34;
    update timestamps by adding microseconds based on the OffsetModel.
    if model not supplied, uses the best offset.
    uses negative values to go backwards in time
    :param om: OffsetModel to calculate offsets, default None
    &#34;&#34;&#34;
    if not om:
        delta = self.best_offset
        self.station_start_timestamp += delta
        self.packet_start_timestamp += delta
        self.packet_end_timestamp += delta
    else:
        self.station_start_timestamp = om.update_time(self.station_start_timestamp)
        self.packet_start_timestamp = om.update_time(self.packet_start_timestamp)
        self.packet_end_timestamp = om.update_time(self.packet_end_timestamp)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.common.timesync.time_sync_data_from_raw_packet" href="#redvox.common.timesync.time_sync_data_from_raw_packet">time_sync_data_from_raw_packet</a></code></li>
<li><code><a title="redvox.common.timesync.update_evenly_sampled_time_array" href="#redvox.common.timesync.update_evenly_sampled_time_array">update_evenly_sampled_time_array</a></code></li>
<li><code><a title="redvox.common.timesync.update_time_array" href="#redvox.common.timesync.update_time_array">update_time_array</a></code></li>
<li><code><a title="redvox.common.timesync.update_time_array_from_analysis" href="#redvox.common.timesync.update_time_array_from_analysis">update_time_array_from_analysis</a></code></li>
<li><code><a title="redvox.common.timesync.validate_sensors" href="#redvox.common.timesync.validate_sensors">validate_sensors</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.timesync.RedvoxPacket" href="#redvox.common.timesync.RedvoxPacket">RedvoxPacket</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.timesync.RedvoxPacket.DESCRIPTOR" href="#redvox.common.timesync.RedvoxPacket.DESCRIPTOR">DESCRIPTOR</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.acquisition_server" href="#redvox.common.timesync.RedvoxPacket.acquisition_server">acquisition_server</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.api" href="#redvox.common.timesync.RedvoxPacket.api">api</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc" href="#redvox.common.timesync.RedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc">app_file_start_timestamp_epoch_microseconds_utc</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.app_file_start_timestamp_machine" href="#redvox.common.timesync.RedvoxPacket.app_file_start_timestamp_machine">app_file_start_timestamp_machine</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.app_version" href="#redvox.common.timesync.RedvoxPacket.app_version">app_version</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.authenticated_email" href="#redvox.common.timesync.RedvoxPacket.authenticated_email">authenticated_email</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.authentication_server" href="#redvox.common.timesync.RedvoxPacket.authentication_server">authentication_server</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.authentication_token" href="#redvox.common.timesync.RedvoxPacket.authentication_token">authentication_token</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.battery_level_percent" href="#redvox.common.timesync.RedvoxPacket.battery_level_percent">battery_level_percent</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.device_make" href="#redvox.common.timesync.RedvoxPacket.device_make">device_make</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.device_model" href="#redvox.common.timesync.RedvoxPacket.device_model">device_model</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.device_os" href="#redvox.common.timesync.RedvoxPacket.device_os">device_os</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.device_os_version" href="#redvox.common.timesync.RedvoxPacket.device_os_version">device_os_version</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.device_temperature_c" href="#redvox.common.timesync.RedvoxPacket.device_temperature_c">device_temperature_c</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.evenly_sampled_channels" href="#redvox.common.timesync.RedvoxPacket.evenly_sampled_channels">evenly_sampled_channels</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.firebase_token" href="#redvox.common.timesync.RedvoxPacket.firebase_token">firebase_token</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.is_backfilled" href="#redvox.common.timesync.RedvoxPacket.is_backfilled">is_backfilled</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.is_private" href="#redvox.common.timesync.RedvoxPacket.is_private">is_private</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.is_scrambled" href="#redvox.common.timesync.RedvoxPacket.is_scrambled">is_scrambled</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.metadata" href="#redvox.common.timesync.RedvoxPacket.metadata">metadata</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.redvox_id" href="#redvox.common.timesync.RedvoxPacket.redvox_id">redvox_id</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.server_timestamp_epoch_microseconds_utc" href="#redvox.common.timesync.RedvoxPacket.server_timestamp_epoch_microseconds_utc">server_timestamp_epoch_microseconds_utc</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.time_synchronization_server" href="#redvox.common.timesync.RedvoxPacket.time_synchronization_server">time_synchronization_server</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.unevenly_sampled_channels" href="#redvox.common.timesync.RedvoxPacket.unevenly_sampled_channels">unevenly_sampled_channels</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacket.uuid" href="#redvox.common.timesync.RedvoxPacket.uuid">uuid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.timesync.RedvoxPacketM" href="#redvox.common.timesync.RedvoxPacketM">RedvoxPacketM</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.timesync.RedvoxPacketM.BYTE" href="#redvox.common.timesync.RedvoxPacketM.BYTE">BYTE</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.CENTIMETERS" href="#redvox.common.timesync.RedvoxPacketM.CENTIMETERS">CENTIMETERS</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.DECIBEL" href="#redvox.common.timesync.RedvoxPacketM.DECIBEL">DECIBEL</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.DECIMAL_DEGREES" href="#redvox.common.timesync.RedvoxPacketM.DECIMAL_DEGREES">DECIMAL_DEGREES</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.DEGREES_CELSIUS" href="#redvox.common.timesync.RedvoxPacketM.DEGREES_CELSIUS">DEGREES_CELSIUS</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.DESCRIPTOR" href="#redvox.common.timesync.RedvoxPacketM.DESCRIPTOR">DESCRIPTOR</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.DoubleSamplePayload" href="#redvox.common.timesync.RedvoxPacketM.DoubleSamplePayload">DoubleSamplePayload</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.EventStream" href="#redvox.common.timesync.RedvoxPacketM.EventStream">EventStream</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.KILOPASCAL" href="#redvox.common.timesync.RedvoxPacketM.KILOPASCAL">KILOPASCAL</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS" href="#redvox.common.timesync.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS">LSB_PLUS_MINUS_COUNTS</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.LUX" href="#redvox.common.timesync.RedvoxPacketM.LUX">LUX</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.METERS" href="#redvox.common.timesync.RedvoxPacketM.METERS">METERS</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.METERS_PER_SECOND" href="#redvox.common.timesync.RedvoxPacketM.METERS_PER_SECOND">METERS_PER_SECOND</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.METERS_PER_SECOND_SQUARED" href="#redvox.common.timesync.RedvoxPacketM.METERS_PER_SECOND_SQUARED">METERS_PER_SECOND_SQUARED</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.MICROAMPERES" href="#redvox.common.timesync.RedvoxPacketM.MICROAMPERES">MICROAMPERES</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH" href="#redvox.common.timesync.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH">MICROSECONDS_SINCE_UNIX_EPOCH</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.MICROTESLA" href="#redvox.common.timesync.RedvoxPacketM.MICROTESLA">MICROTESLA</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.MetadataEntry" href="#redvox.common.timesync.RedvoxPacketM.MetadataEntry">MetadataEntry</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.NORMALIZED_COUNTS" href="#redvox.common.timesync.RedvoxPacketM.NORMALIZED_COUNTS">NORMALIZED_COUNTS</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.PCM" href="#redvox.common.timesync.RedvoxPacketM.PCM">PCM</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.PERCENTAGE" href="#redvox.common.timesync.RedvoxPacketM.PERCENTAGE">PERCENTAGE</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.RADIANS" href="#redvox.common.timesync.RedvoxPacketM.RADIANS">RADIANS</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.RADIANS_PER_SECOND" href="#redvox.common.timesync.RedvoxPacketM.RADIANS_PER_SECOND">RADIANS_PER_SECOND</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.SamplePayload" href="#redvox.common.timesync.RedvoxPacketM.SamplePayload">SamplePayload</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.Sensors" href="#redvox.common.timesync.RedvoxPacketM.Sensors">Sensors</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.StationInformation" href="#redvox.common.timesync.RedvoxPacketM.StationInformation">StationInformation</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.SummaryStatistics" href="#redvox.common.timesync.RedvoxPacketM.SummaryStatistics">SummaryStatistics</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.TimingInformation" href="#redvox.common.timesync.RedvoxPacketM.TimingInformation">TimingInformation</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.TimingPayload" href="#redvox.common.timesync.RedvoxPacketM.TimingPayload">TimingPayload</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.UNITLESS" href="#redvox.common.timesync.RedvoxPacketM.UNITLESS">UNITLESS</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.UNKNOWN" href="#redvox.common.timesync.RedvoxPacketM.UNKNOWN">UNKNOWN</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.Unit" href="#redvox.common.timesync.RedvoxPacketM.Unit">Unit</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.api" href="#redvox.common.timesync.RedvoxPacketM.api">api</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.event_streams" href="#redvox.common.timesync.RedvoxPacketM.event_streams">event_streams</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.metadata" href="#redvox.common.timesync.RedvoxPacketM.metadata">metadata</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.sensors" href="#redvox.common.timesync.RedvoxPacketM.sensors">sensors</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.station_information" href="#redvox.common.timesync.RedvoxPacketM.station_information">station_information</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.sub_api" href="#redvox.common.timesync.RedvoxPacketM.sub_api">sub_api</a></code></li>
<li><code><a title="redvox.common.timesync.RedvoxPacketM.timing_information" href="#redvox.common.timesync.RedvoxPacketM.timing_information">timing_information</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.timesync.TimeSyncAnalysis" href="#redvox.common.timesync.TimeSyncAnalysis">TimeSyncAnalysis</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.add_timesync_data" href="#redvox.common.timesync.TimeSyncAnalysis.add_timesync_data">add_timesync_data</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.evaluate_and_validate_data" href="#redvox.common.timesync.TimeSyncAnalysis.evaluate_and_validate_data">evaluate_and_validate_data</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.evaluate_latencies" href="#redvox.common.timesync.TimeSyncAnalysis.evaluate_latencies">evaluate_latencies</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.from_packets" href="#redvox.common.timesync.TimeSyncAnalysis.from_packets">from_packets</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.from_raw_packets" href="#redvox.common.timesync.TimeSyncAnalysis.from_raw_packets">from_raw_packets</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_bad_packets" href="#redvox.common.timesync.TimeSyncAnalysis.get_bad_packets">get_bad_packets</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_best_latency" href="#redvox.common.timesync.TimeSyncAnalysis.get_best_latency">get_best_latency</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_best_offset" href="#redvox.common.timesync.TimeSyncAnalysis.get_best_offset">get_best_offset</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_best_packet_latency_index" href="#redvox.common.timesync.TimeSyncAnalysis.get_best_packet_latency_index">get_best_packet_latency_index</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_best_start_time" href="#redvox.common.timesync.TimeSyncAnalysis.get_best_start_time">get_best_start_time</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_latencies" href="#redvox.common.timesync.TimeSyncAnalysis.get_latencies">get_latencies</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_latency_stdev" href="#redvox.common.timesync.TimeSyncAnalysis.get_latency_stdev">get_latency_stdev</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_mean_latency" href="#redvox.common.timesync.TimeSyncAnalysis.get_mean_latency">get_mean_latency</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_mean_offset" href="#redvox.common.timesync.TimeSyncAnalysis.get_mean_offset">get_mean_offset</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_num_packets" href="#redvox.common.timesync.TimeSyncAnalysis.get_num_packets">get_num_packets</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_offset_model" href="#redvox.common.timesync.TimeSyncAnalysis.get_offset_model">get_offset_model</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_offset_stdev" href="#redvox.common.timesync.TimeSyncAnalysis.get_offset_stdev">get_offset_stdev</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_offsets" href="#redvox.common.timesync.TimeSyncAnalysis.get_offsets">get_offsets</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.get_start_times" href="#redvox.common.timesync.TimeSyncAnalysis.get_start_times">get_start_times</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.update_timestamps" href="#redvox.common.timesync.TimeSyncAnalysis.update_timestamps">update_timestamps</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.validate_sample_rate" href="#redvox.common.timesync.TimeSyncAnalysis.validate_sample_rate">validate_sample_rate</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.validate_start_timestamp" href="#redvox.common.timesync.TimeSyncAnalysis.validate_start_timestamp">validate_start_timestamp</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncAnalysis.validate_time_gaps" href="#redvox.common.timesync.TimeSyncAnalysis.validate_time_gaps">validate_time_gaps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.timesync.TimeSyncData" href="#redvox.common.timesync.TimeSyncData">TimeSyncData</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.timesync.TimeSyncData.get_best_latency_timestamp" href="#redvox.common.timesync.TimeSyncData.get_best_latency_timestamp">get_best_latency_timestamp</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncData.num_tri_messages" href="#redvox.common.timesync.TimeSyncData.num_tri_messages">num_tri_messages</a></code></li>
<li><code><a title="redvox.common.timesync.TimeSyncData.update_timestamps" href="#redvox.common.timesync.TimeSyncData.update_timestamps">update_timestamps</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>